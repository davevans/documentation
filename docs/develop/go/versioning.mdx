---
id: versioning
title: Workflow Versioning - Go SDK
description: Achieve Workflow expertise in Temporal's Go SDK with Patching APIs & Workflow Versioning.
sidebar_label: Workflow Versioning
toc_max_heading_level: 3
keywords:
  - determinism
  - go sdk
  - patching
  - versioning
  - workflows
tags:
  - Workflows
  - Go SDK
  - Temporal SDKs
---

:::note Example Only: For docs team sync

- Does not demonstrate snipsync (there is no go sample for patching)
- Removed prerelease section (Can be restored)
- Brian would like this version to persist and be incorporated
  - Add request for replay testing as best practice
  - Mine from Python version, Typescript version, and the Versioning Course for content.
  - Contact Spencer (look for Replay Tests in Jira)

:::


Updating distributed systems can be challenging.
This is especially true when you need to maintain Workflow Execution integrity as you migrate and evolve your code.
Whether you’re fixing bugs or rolling out new versions, Workflows need to run smoothly and be ready to re-create system state on demand.

This page introduces mechanisms that keep your Workflow Definition code and your Workflow Execution Event Histories aligned, even when you need to update them.
Adding Workflow Versioning lets your code runs smoothly, whether you're patching code, using Replays, or performing Replay tests.

## Deterministic code and Replays

Durability starts with code that's deterministic.
Determinism means that when code receives the same input, your Workflow always goes through identical state changes and produces the same output, no matter when or where it runs.
[Determinism](/workflows#deterministic-constraints) is key to Temporal's ability to replay Workflow state for truly durable execution.

Determinism is particularly important for workflows with multiple stages, components, and state changes.
Deterministic code is easier to understand, test, and maintain.
It’s a crucial part of ensuring reliability.
When working with Orchestration and Replay, determinism makes sure that Workflow Executions always produce the same outcome for the same inputs.
Workflows depend on deterministic code to keep their processes consistent across executions and Replays.

Replays happen for many reasons.
For example, you might recover an interrupted Workflow or perform Replay testing before deployment.
If your Event History doesn't match your replayed Workflow, your code _will_ break.
Unless your code is guaranteed to have that 1:1 correspondence, it isn't deterministic, and it isn't compatible with Durable Execution.
Correspondence means creating the same sequence, the same state, and the same results.

Determinism allows Temporal to accurately replay History events and ensures that the outcome remains unchanged, no matter when or where the Replay happens.
It maintains system integrity and it's essential for Durable Execution.
Because of this, the Temporal Platform, and the Temporal Go SDK specifically, require all Workflow code to be deterministic.

That's why you must make sure that every Workflow is deterministic, even when it undergoes change.

## Change and durable execution

Maintaining determinism even when you update code is the key to creating versioned patches.
This predictability plays a vital role in debugging, reliability, and consistent performance, especially with complex Workflows and long-running processes.
That's because change and Workflow Executions may overlap.
It's your job to make sure that overlap remains deterministic.

Since Workflow Executions might run for months or years, you may make major changes to a Workflow Definition while Workflow Executions are still in progress.
For example, imagine that your Workflow currently notifies a customer when an order is shipped with an e-mail notification.
You later decide to update this to allow a customer to opt into sending a text notification as well or instead.
Versioning is a Temporal feature that helps manage code changes safely during any kind of Replay event.

- Maybe someone tripped over a power cord in your Worker farm at the same time your development team issues a new release.
- Maybe your team is re-running Event Histories to try to track down a persistent bug.
- Maybe you just have a lot of long-running Workflow Executions and need to deploy updates.

Temporal's Go SDK helps you work through updating your Workflow Definition logic.
When you roll out changes with Temporal, your focus needs to be on safety and reliability.
Temporal's patching APIs and version markers let you support in-flight and replayed Workflow Executions even as you deploy bug fixes and enhancements for newly started ones.
Between patching and determinism checks, you have the tools you need to keep your Temporal applications well-maintained and ready to adapt and grow.

Versioning is an SDK feature that lets you make, support, and test your code updates.

## Versioning and patching features

Workflow Patching APIs let you modify Workflow code without introducing non-deterministic behavior.
Versioning ensures the code you run is consistent with each Execution's original deployment.

There will be times a Workflow Execution needs serious intervention, such as when you meet significant code changes that make versioning impractical.
New laws may come into effect causing the need for data cleanup or regulatory compliance.
You might need to revert Workflow Executions to an earlier state or you have to mitigate unrecoverable Activity failures.
In these cases, you might need to terminate and restart Workflows.
Patching is, as the name suggests, the process to fix bugs, improve performance, or add new features.
It's not meant for re-architecting Workflows.

Temporal's Patching APIs create logical branches inside your Workflow Definition code.
They use developer-specified version identifiers to choose pathways based on the circumstances under which your Workflow Execution began.
This section shows ways your team can enhance, adapt, and evolve Workflow code, while preserving ongoing functionality to maintain stability.

Read on to learn more.

:::tip
Temporal is designed for Workflows that run at scale and may be potentially long-running.
This [30-minute video](https://www.youtube.com/watch?v=kkP899WxgzY) explains determinism issues in more depth.
:::

## Patching {#patching}

What do you do when your code changes over time?
Patching lets you update code without breaking determinism.
The Go SDK's patching APIs create logical branches within your Workflow Definition code.
It works by using version identifiers that direct the flow of your code into new branches, creating patched and updated deployments.

Patches, like Workflow Definitions in general, must be deterministic.
That's because when needed, Temporal uses event sourcing to reconstruct Workflow state.
It replays saved [Event History](/encyclopedia/retry-policies#event-history) data and  applies it to your Workflow Definition code.
Incompatible updates will cause non-deterministic errors.

To understand how patching works, read about what happens when you substitute code without using the patching APIs.

### How not to patch

Consider the following Workflow Definition.
It creates a Workflow with Activity options, then runs Activity A and then Activity B:

```go
func YourWorkflow(ctx workflow.Context, data string) (string, error) {
    ao := workflow.ActivityOptions{
        ScheduleToStartTimeout: time.Minute,
        StartToCloseTimeout:    time.Minute,
    }
    ctx = workflow.WithActivityOptions(ctx, ao)
    var result1 string

    // Run ActivityA
    err := workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)

    // Activity A has completed running and `result1` retrieved

    if err != nil {
        return "", err
    }

    // Run Activity B
    var result2 string
    err = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)

    // Activity B has completed running and `result2` retrieved

    return result2, err
}
```

In this example, what would happen when you replace `ActivityA` with `ActivityC` and deploy that updated Workflow Definition code?

A Workflow Definition's signature, that is the Tasks, Activities, and Server-side [Commands](https://docs.temporal.io/workflows#command) it generates, are checked before retrieving Activity results.
When the signature doesn't match, the Temporal Service raises a nondeterminism error.

Patching must be reliable and predictable.
In Go, you should approach code changes by using versions and change identifiers.

### Versions and change identifiers {#versions-and-change-ids}

Following onto the example in the preceding section, say there's an existing Workflow Execution.
This execution started running using the original Workflow Definition, which used `ActivityA` as its first Activity.
Now, the Workflow Execution needs to be replayed.
Maybe someone tripped over a power strip and knocked out Workers in one of your deployment fleets.
Unless you update your code to take the patch from `ActivityA` to `ActivityC` into account, this Workflow Execution can't move forward without generating a nondeterminism error.
To resolve this situation, update the code to use `workflow.GetVersion`.

`workflow.GetVersion()` takes three arguments: a String change Id, the minimum  supported deployed version (Integer), and the maximum supported deployed version (Integer):

- A **change Id** in Temporal is an arbitrary unique String identifier used for Worker patching and versioning.
  For example, it might be called "Step1", since this is the first step in the Workflow process.
  You can use up to 255 characters.
  The Id works with `workflow.GetVersion()` to mark and manage patched changes in Workflow code.
- The **minimum deployed version** is the oldest supported version for this Workflow Definition.
  A special constant, `workflow.DefaultVersion`, represents the version of code that wasn't versioned before, supplying the canonical initial or default version of any Workflow.
  In Go, that version is `-1`.
- The **maximum deployed version** is the latest supported version for this Workflow Definition.
  The number is automatically managed by Temporal and stored on the Server using the argument passed to `GetVersion`.

Here is the patched version of this code.
This example is ready for both new Workflow Executions and replayed original versions whose execution has not yet closed:

```go

var err error

var result1 string

// This line is added when the `ActivityC` patch was deployed
v := workflow.GetVersion(ctx, "Step1", workflow.DefaultVersion, 1)

// Check the version of the Workflow
if v == workflow.DefaultVersion {
    // This logic is only used for Replays of the original version.
    // `GetVersion` does not write when called during Replays.
    err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)
} else if v == 1 {
    // Once `GetVersion` has been run, a Marker called "Version" is recorded in History with a value of 1
    // It is also read during Replays.
    err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)
} else {
   // Handle the pathological case that should never happen
}
if err != nil {
    return "", err
}
```

When `workflow.GetVersion()` is run for a new Workflow Execution, it records a marker in that Workflow's Event History.
Markers are custom events that are transparent to the Temporal Server.
That is, the Server stores it but does not try to interpret its contents.
`GetVersion` sets a Marker called "Version".
It names the Version using the change Id string you passed.
It sets its value to the maximum deployed version passed in the arguments.

During Replays, `GetVersion` doesn't write.
It will only attempt to read the version.
For an unpatched Workflow Execution, such as the original one with `ActivityA`, this defaults to the `workflow.DefaultVersion`.

This means that:

- Any Workflow Execution that ran with `ActivityA` will not have a Version Marker.
- Any Workflow Execution that ran with `ActivityC`, which includes a call to `GetVersion`, will record the maximum version on its first run and read the version when replayed.

This patching approach does not require you to retain eternal backwards compatibility.
Once you've closed all Workflow Executions using the original version, you can update your code and move forward.

### Retiring patches {#retiring-patches}

After all Workflow Executions that were started before the deployment of the `ActivityC` patch are closed, you can safely remove the logic for those versions.
Do, however, take into account any forensic work you might do in the future on Event Histories.
Re-running Histories can be valuable for insights into bugs or performance.
Never remove version logic you may have to return to.

Revising supported versions is an ongoing process.
As new patches are added to your Workflow Definition, you can continue to add and remove branches to your testing logic.

For example:

```go

var err error

var result1 string

// This line was updated when retiring `ActivityA` and introducing `ActivityD`
v := workflow.GetVersion(ctx, "Step1", 1, 2)

// Check the version of the Workflow
if v == 1 {
    err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)
} else if v == 2 {
    err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)
} else {
   // Handle the pathological case that should never happen
}
if err != nil {
    return "", err
}

...
```

If an older version using the `ActivityA` Workflow Execution History is replayed on this code, it will fail.
The minimum expected version is 1, raising an `UnsupportedVersion` error.

Some tips:

- You must update versions each time you patch the same logic.
- You may only remove the first (`ActivityA`) call to `GetVersion()` when there are no longer potential Replay conflicts.
- After removing `GetUpdate` calls, if you need to patch that area again, you must use a new change identifier.
  That's because your open Workflow Executions may no longer have consistent Markers in their Event Histories.
- If you don't want to use versions or if your changes will be extensive, you can wait for all existing Workflow Executions to complete and suspend new ones from being created before deploying the new version of your Workflow code.

## Detecting nondeterminism {#sanity-checking}

Knowing when nondeterminism happens is an important part of Temporal durable execution.
Detecting nondeterminism isn’t always possible because finding instances of nondeterminism can be too complicated to automate.
However, Temporal does try its best.
It applies automatic detection under several circumstances:

- During Replay, a Worker ensures each replayed [Command](https://docs.temporal.io/workflows#command) from an Event History is fully aligned with the corresponding Command in the active Workflow Definition.
  A Command is an action issued by a Worker to the Temporal Service after a Workflow Task Execution completes.
  This also includes Replay Unit Testing.
- Some SDKs perform runtime checks to detect potential non-deterministic behavior.
  For example, the .NET SDK uses an event listener to catch unsafe threading operations.
- Some SDKs, like TypeScript, use isolated virtual machines with continuous checking to ensure that Workflows cannot violate determinism.
- Some SDKs, like Go, offer Static Analysis tooling that look for invalid code constructions that could lead to nondeterminism.

Although these checks can't catch all issues, they cover a good range of possible problems.

### Replay checks

You might wonder how the Replay knows when it's encountered deterministic code.
This happens during a Replay check.
A Replay check ensures that any Command in the following list that is made in Replay matches the Event recorded in the Event History, and appears in the same order:

- `workflow.ExecuteActivity()`
- `workflow.ExecuteChildWorkflow()`
- `workflow.NewTimer()`
- `workflow.RequestCancelWorkflow()`
- `workflow.SideEffect()`
- `workflow.SignalExternalWorkflow()`
- `workflow.Sleep()`

Adding, removing, or reordering any of these methods from your Workflow Definition can result in a nondeterminism error.

### Checking limitations

No determinism checks are perfect.
For example, Replay tests do not check on an Activity's input arguments or Timer durations.
If checks are enforced on every property, test implementation becomes too restrictive and harder to maintain within your Workflow code.

## Read more

To learn more about patching and versioning your Workflow code, check out these resources:

**Documentation**

- [Encyclopedia: Versioning Workflow code](/workflows#workflow-versioning)

**Courses and Tutorials**

- [Versioning Workflows](https://learn.temporal.io/courses/versioning/)
- [Temporal 102: Exploring Durable Execution](https://learn.temporal.io/courses/temporal_102/)
- [Typescript Background Check: Durable Execution](https://learn.temporal.io/tutorials/typescript/background-check/durable-execution/)
- [Java Background Check: Durable Execution](https://learn.temporal.io/tutorials/java/background-check/durable-execution/)

**Blog Posts**

- [Temporal Spooky Stories: Anti-patterns](https://temporal.io/blog/spooky-stories-chilling-temporal-anti-patterns-part-1)

## Worker Versioning

:::warning

Worker Versioning is a [Pre-release](/evaluate/development-production-features/release-stages#pre-release) feature and will not be documented for the Go SDK until it reaches [Public Preview](/evaluate/development-production-features/release-stages#public-preview).

:::
