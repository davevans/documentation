<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Temporal SDK Development Guide</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" /> <!-- Added Prism CSS -->
  </head>
  <body>
    <header>
      <h1>Temporal SDK Development Guide</h1>
    </header>

    <div class="layout-container"> <!-- Add wrapper div -->
      <nav id="main-nav">
        <ul>
          <li><a href="#core-concepts">Core Concepts</a>
            <ul>
              <li><a href="#temporal-application">What is a Temporal Application?</a></li>
              <li><a href="#workflows">Workflows</a></li>
              <li><a href="#activities">Activities</a></li>
              <li><a href="#workers">Workers</a></li>
              <li><a href="#task-queues">Task Queues</a></li>
            </ul>
          </li>
          <li><a href="#setup">Setup</a>
            <ul>
              <li><a href="#temporal-cli">Temporal CLI & Dev Server</a></li>
              <li><a href="#sdk-installation">SDK Installation</a></li>
            </ul>
          </li>
          <li><a href="#workflow-definition">Workflow Definition</a>
              <ul>
                  <li><a href="#workflow-definition">Overview</a></li>
                  <li><a href="#workflow-constraints">Constraints (Determinism)</a></li>
              </ul>
          </li>
          <li><a href="#activity-definition">Activity Definition</a>
              <ul>
                  <li><a href="#activity-definition">Overview</a></li>
                  <li><a href="#activity-context">Context & Info</a></li>
                  <li><a href="#activity-registration">Registration</a></li>
              </ul>
          </li>
          <!-- TODO: Add Worker Process Nav -->
          <!-- TODO: Add Run Application Nav -->
          <li><a href="#temporal-client">Temporal Client</a>
              <ul>
                  <li><a href="#client-connection">Connection</a></li>
                  <li><a href="#start-workflow-execution">Start Execution</a></li>
                  <li><a href="#get-workflow-result">Get Result</a></li>
                  <li><a href="#signal-workflows">Signal</a></li>
                  <li><a href="#query-workflows">Query</a></li>
                  <li><a href="#terminate-workflows">Terminate</a></li>
                  <li><a href="#cancel-workflows">Cancel</a></li>
              </ul>
          </li>
          <li><a href="#advanced-concepts">Advanced Concepts</a>
              <ul>
                  <li><a href="#activity-heartbeating">Activity Heartbeating</a></li>
                  <li><a href="#activity-async-completion">Async Completion</a></li>
                  <li><a href="#activity-cancellation">Activity Cancellation</a></li>
                  <li><a href="#workflow-versioning">Workflow Versioning</a></li>
                  <li><a href="#child-workflows">Child Workflows</a></li>
                  <li><a href="#continue-as-new">Continue-As-New</a></li>
                  <li><a href="#side-effects">Side Effects</a></li>
                  <li><a href="#local-activities">Local Activities</a></li>
                  <li><a href="#mutations">Mutations</a></li>
              </ul>
          </li>
          <li><a href="#testing">Testing</a>
              <ul>
                  <li><a href="#testing-overview">Overview</a></li>
                  <li><a href="#workflow-replay">Workflow Replay</a></li>
                  <li><a href="#testing-environment">Integration Testing</a></li>
              </ul>
          </li>
        </ul>
      </nav>

      <main id="content">
        <!-- Core Concepts Section -->
        <section id="core-concepts">
          <h2>Core Concepts</h2>

          <article id="temporal-application">
            <h3>What is a Temporal Application?</h3>
            <p>
              A Temporal Application is a collection of Workflow Definitions, Activity Definitions, and Worker Processes
              that execute your business logic. It relies on a Temporal Service (either Temporal Cloud or a self-hosted
              cluster) to manage the state and execution of Workflows reliably.
            </p>
          </article>

          <article id="workflows">
            <h3>Workflows</h3>
            <p>
              A Workflow is the core abstraction in Temporal, representing a durable, reliable, and potentially
              long-running function execution. Workflows orchestrate the execution of Activities to achieve a business
              goal.
            </p>
            <h4>Key Properties:</h4>
            <ul>
              <li>
                <strong>Durability:</strong> Workflow state is persisted by the Temporal Service, allowing execution to
                survive process failures and resume automatically.
              </li>
              <li>
                <strong>Reliability:</strong> The Temporal Platform guarantees that Workflow code executes exactly once to
                completion, handling retries and failures transparently.
              </li>
              <li>
                <strong>Deterministic Constraints:</strong> Workflow code must be deterministic. This means it must
                produce the same output given the same input, without relying on external system state or side effects
                (except through Activities).
              </li>
            </ul>
            <p>
              Workflows are defined as functions or methods in your chosen SDK language. They interact with the Temporal
              system via SDK APIs to schedule Activities, manage timers, wait for external events (Signals), and more.
            </p>
          </article>

          <article id="activities">
            <h3>Activities</h3>
            <p>
              An Activity represents a single, well-defined unit of work within a Workflow, typically involving
              interaction with the outside world (for example, database calls, API requests, sending emails).
            </p>
            <h4>Key Properties:</h4>
            <ul>
              <li>
                <strong>Non-deterministic Code:</strong> Unlike Workflows, Activity code can interact freely with external
                systems and perform non-deterministic operations.
              </li>
              <li>
                <strong>Managed Execution:</strong> Activities are executed by Workers. The Temporal Platform manages
                their retries, timeouts, and tracking based on configured policies.
              </li>
              <li>
                <strong>Idempotent Design:</strong> Activities should ideally be designed to be idempotent. This means
                executing them multiple times with the same input yields the same result, which is crucial for handling
                potential retries safely.
              </li>
            </ul>
            <p>Activities are defined as functions or methods and are invoked asynchronously from Workflows.</p>
          </article>

          <article id="workers">
            <h3>Workers</h3>
            <p>
              A Worker is a process that hosts Workflow and Activity implementations. Workers poll Task Queues on the
              Temporal Service, receive Tasks (representing Workflow or Activity executions), execute the corresponding
              code, and report results back.
            </p>
            <h4>Responsibilities:</h4>
            <ul>
              <li>Execute Workflow logic based on its history.</li>
              <li>Execute Activity Tasks, interacting with external systems as needed.</li>
              <li>Communicate with the Temporal Service to fetch Tasks and report progress/results.</li>
            </ul>
            <p>
              You can run multiple Worker processes for scalability and fault tolerance. Workers are stateless regarding
              Workflow executions (state is maintained by the Cluster), but they manage Activity execution state locally
              (for example, if an Activity needs to checkpoint progress).
            </p>
          </article>

          <article id="task-queues">
            <h3>Task Queues</h3>
            <p>
              A Task Queue is a lightweight, dynamic queue managed by the Temporal Service. When a Workflow Execution is
              started or an Activity is scheduled, a Task is placed onto a specific Task Queue.
            </p>
            <h4>Purpose:</h4>
            <ul>
              <li>
                <strong>Routing:</strong> Workers listen on specific Task Queues. This directs Tasks to the appropriate
                set of Workers capable of handling them.
              </li>
              <li>
                <strong>Load Balancing:</strong> The Temporal Service distributes Tasks from a queue among the available
                Workers listening on it.
              </li>
              <li>
                <strong>Prioritization (Enterprise):</strong> Task Queues can be configured for task prioritization in
                Temporal Cluster versions supporting it.
              </li>
            </ul>
            <p>Task Queues are fundamental for decoupling Workflow/Activity scheduling from Worker execution.</p>
          </article>
        </section>
        <!-- End Core Concepts Section -->

        <!-- Setup Section -->
        <section id="setup">
          <h2>Setup and Installation</h2>

          <article id="temporal-cli">
            <h3>Temporal CLI and Development Server</h3>
            <p>
              The <a href="/cli">Temporal CLI</a> is essential for interacting with a Temporal Service (including Temporal
              Cloud) and includes a lightweight development server for local testing. This server runs as a single process
              with an in-memory database (or optional file persistence) and includes the Temporal Web UI.
            </p>

            <h4>CLI Installation</h4>
            <p>The CLI is available for macOS, Linux, and Windows.</p>
            <ul>
              <li><strong>macOS (Homebrew):</strong> <code>brew install temporal</code></li>
              <li><strong>Linux (Homebrew):</strong> <code>brew install temporal</code></li>
              <li>
                <strong>Manual Download (All Platforms):</strong> Visit
                <a href="https://temporal.io/download">temporal.io/download</a>, select your platform/architecture,
                download the archive, extract it, and add the <code>temporal</code> (or <code>temporal.exe</code>) binary
                to your system's PATH.
              </li>
            </ul>

            <h4>Development Server Execution</h4>
            <p>Start the development server using the following command:</p>
            <pre><code class="language-bash">temporal server start-dev</code></pre>
            <p>
              This command starts the server (listening on <code>localhost:7233</code> by default), creates the default
              <code>default</code> Namespace, and starts the Web UI (accessible at
              <a href="http://localhost:8233">http://localhost:8233</a>).
            </p>
          </article>

          <article id="sdk-installation">
            <h3>SDK Installation</h3>
            <p>Install the Temporal SDK for your preferred language:</p>

            <div class="tab-container" id="sdk-install-tabs">
              <div class="tab-buttons">
                <button class="tab-button" data-tab-target="sdk-install-go">Go</button>
                <button class="tab-button" data-tab-target="sdk-install-java">Java</button>
                <button class="tab-button" data-tab-target="sdk-install-dotnet">.NET</button>
                <button class="tab-button" data-tab-target="sdk-install-php">PHP</button>
                <button class="tab-button" data-tab-target="sdk-install-python">Python</button>
                <button class="tab-button" data-tab-target="sdk-install-ts">TypeScript</button>
              </div>
              <!-- Tab content divs moved inside tab-container -->
              <div class="tab-content" id="sdk-install-go">
                <h4>Go</h4>
                <p>Add the Go SDK module to your project:</p>
                <pre><code class="language-bash">go get go.temporal.io/sdk</code></pre>
                <p>Or clone the repository:</p>
                <pre><code class="language-bash">git clone https://github.com/temporalio/sdk-go.git</code></pre>
                <p>API Reference: <a href="https://pkg.go.dev/go.temporal.io/sdk">pkg.go.dev/go.temporal.io/sdk</a></p>
              </div>

              <div class="tab-content" id="sdk-install-java">
                <h4>Java</h4>
                <p>Add the Temporal SDK dependency to your project using Maven or Gradle.</p>
                <p><strong>Maven (<code>pom.xml</code>):</strong></p>
                <pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;io.temporal&lt;/groupId&gt;
  &lt;artifactId&gt;temporal-sdk&lt;/artifactId&gt;
  &lt;version&gt;LATEST_VERSION&lt;/version&gt; &lt;!-- Replace with desired version --&gt;
&lt;/dependency&gt;</code></pre>
                <p><strong>Gradle (<code>build.gradle</code>):</strong></p>
                <pre><code class="language-gradle">implementation \'io.temporal:temporal-sdk:LATEST_VERSION\' // Replace with desired version</code></pre>
                <p>
                  Find the latest version on
                  <a href="https://search.maven.org/artifact/io.temporal/temporal-sdk">Maven Central</a>.
                </p>
                <p>
                  API Reference:
                  <a href="https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/index.html">Javadoc</a>
                </p>
              </div>

              <div class="tab-content" id="sdk-install-dotnet">
                <h4>.NET</h4>
                <p>Add the Temporal .NET SDK package to your project using the .NET CLI:</p>
                <pre><code class="language-bash">dotnet add package Temporalio</code></pre>
                <p>Or using NuGet Package Manager.</p>
                <p>API Reference: <a href="https://dotnet.temporal.io/">dotnet.temporal.io</a></p>
              </div>

              <div class="tab-content" id="sdk-install-php">
                <h4>PHP</h4>
                <p>Install the SDK using Composer:</p>
                <pre><code class="language-bash">composer require temporal/sdk</code></pre>
                <p>API Reference: <a href="https://php.temporal.io/namespaces/temporal.html">php.temporal.io</a></p>
              </div>

              <div class="tab-content" id="sdk-install-python">
                <h4>Python</h4>
                <p>Install the SDK using pip:</p>
                <pre><code class="language-bash">pip install temporalio</code></pre>
                <p>Requires Python 3.8+.</p>
                <p>API Reference: <a href="https://python.temporal.io/">python.temporal.io</a></p>
              </div>

              <div class="tab-content" id="sdk-install-ts">
                <h4>TypeScript / JavaScript</h4>
                <p>Create a new project using the Temporal initializer:</p>
                <pre><code class="language-bash">npx @temporalio/create@latest ./your-app</code></pre>
                <p>Or add to an existing project (requires Node.js 16.15+):</p>
                <pre><code class="language-bash">npm install @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity @temporalio/common</code></pre>
                <p>API Reference: <a href="https://typescript.temporal.io/">typescript.temporal.io</a></p>
              </div>
            </div> <!-- End tab-container -->
          </article>
        </section>
        <!-- End Setup Section -->

        <!-- Workflow Development Section -->
        <section id="workflow-development">
          <h2>Workflow Development</h2>
          <p>
              Workflows orchestrate Activities and manage durable state. They execute deterministically, ensuring
              resilience against failures.
          </p>

          <article id="workflow-definition">
              <h3>Workflow Definition</h3>
              <p>
              Define Workflows using interfaces and implementations (Java, Go, PHP) or functions/classes (Python,
              TypeScript, .NET). Workflow logic must be deterministic.
              </p>

              <!-- Tabs for Workflow Definition -->
              <div class="tab-container">
                <div class="tab-buttons">
                  <button class="tab-button" data-tab-target="workflow-def-ts">
                      TypeScript
                  </button>
                  <button class="tab-button" data-tab-target="workflow-def-py">
                      Python
                  </button>
                  <button class="tab-button" data-tab-target="workflow-def-go">
                      Go
                  </button>
                  <button class="tab-button" data-tab-target="workflow-def-java">
                      Java
                  </button>
                  <button class="tab-button" data-tab-target="workflow-def-dotnet">
                      .NET
                  </button>
                  <button class="tab-button" data-tab-target="workflow-def-php">
                      PHP
                  </button>
                </div>

                <div class="tab-content" id="workflow-def-ts">
                  <h4>TypeScript</h4>
                  <p>Define Workflow logic within an async function.</p>
                  <pre><code class="language-typescript">import * as wf from '@temporalio/workflow';
import * as activities from './activities'; // Assuming activities.ts defines activities

// Define Activities using an interface or proxy object.
const { composeGreeting } = wf.proxyActivities&lt;typeof activities&gt;({
  startToCloseTimeout: '1 minute',
});

/** A Workflow Definition */
export async function exampleWorkflow(name: string): Promise&lt;string&gt; {
  const greeting = await composeGreeting('Hello', name);
  return greeting;
}</code></pre>
                </div>

                <div class="tab-content" id="workflow-def-py">
                  <h4>Python</h4>
                  <p>Define Workflows within classes.</p>
                  <pre><code class="language-python">from temporalio import workflow
from datetime import timedelta
import activities # Assume activities.py defines compose_greeting

# Import activity stubs (created via @activity.defn)
# Use this approach for type safety if stubs generated
# from activities import GreetingActivities

@workflow.defn
class GreetingWorkflow:
    @workflow.run
    async def run(self, name: str) -> str:
        # Execute an Activity
        return await workflow.execute_activity(
            compose_greeting,
            ("Hello", name),
            start_to_close_timeout=timedelta(minutes=1),
        )</code></pre>
                </div>

                <div class="tab-content" id="workflow-def-go">
                  <h4>Go</h4>
                  <p>Define Workflows as functions.</p>
                  <pre><code class="language-go">package app

import (
"time"
"go.temporal.io/sdk/workflow"
"activities" // Assuming activities package defines ComposeGreeting
)

// Assumes activities.go defines ComposeGreeting

func YourWorkflow(ctx workflow.Context, name string) (string, error) {
ao := workflow.ActivityOptions{
    StartToCloseTimeout: time.Minute,
}
ctx = workflow.WithActivityOptions(ctx, ao)

var result string
err := workflow.ExecuteActivity(ctx, ComposeGreeting, "Hello", name).Get(ctx, &result)
if err != nil {
    return "", err
}
return result, nil
}</code></pre>
                </div>

                <div class="tab-content" id="workflow-def-java">
                  <h4>Java</h4>
                  <p>Define a Workflow interface annotated with <code>@WorkflowInterface</code> and implement it.</p>
                  <pre><code class="language-java">package your.application; // Use your actual package name

import io.temporal.workflow.WorkflowInterface;
import io.temporal.workflow.WorkflowMethod;
import io.temporal.activity.ActivityOptions;
import io.temporal.common.RetryOptions;
import io.temporal.workflow.Workflow; // Import Workflow class
import java.time.Duration;
import your.application.activities.YourActivities; // Assume YourActivities interface exists in activities subpackage

@WorkflowInterface
public interface YourWorkflow {
    @WorkflowMethod
    String execute(String name);
}

public class YourWorkflowImpl implements YourWorkflow {
    private final YourActivities activities;

    public YourWorkflowImpl() {
    // Configure Activity options
    ActivityOptions options = ActivityOptions.newBuilder()
        .setStartToCloseTimeout(Duration.ofMinutes(1))
        // Optional: Configure retry options
        .setRetryOptions(RetryOptions.newBuilder()
            .setMaximumAttempts(3)
            .build())
        .build();
    // Create an Activity stub
    this.activities = Workflow.newActivityStub(YourActivities.class, options);
    }

    @Override
    public String execute(String name) {
    // Execute an Activity by calling its method
    return activities.doWork("Hello " + name);
    }
}</code></pre>
                </div>

                <div class="tab-content" id="workflow-def-dotnet">
                  <h4>.NET</h4>
                  <p>Define Workflows in classes, marking the entry point with <code>[WorkflowRun]</code>.</p>
                  <pre><code class="language-csharp">using Temporalio.Workflows;
using Temporalio.Activities; // For Activity scheduling options if needed
using System;
using System.Threading.Tasks;
using YourApplication.Activities; // Assume YourApplication.Activities.MyActivities class exists

[Workflow]
public class YourWorkflow
{
    [WorkflowRun]
    public async Task&lt;string&gt; RunAsync(string name)
    {
    // Execute an Activity
    return await Workflow.ExecuteActivityAsync&lt;string&gt;(
        (MyActivities act) => act.ComposeGreetingAsync("Hello", name),
        new ActivityOptions { StartToCloseTimeout = TimeSpan.FromMinutes(1) }
    );
    }
}</code></pre>
                </div>

                <div class="tab-content" id="workflow-def-php">
                  <h4>PHP</h4>
                  <p>Define a Workflow interface annotated with <code>#[WorkflowInterface]</code> and implement it.</p>
                  <pre><code class="language-php">&lt;?php
namespace App\Workflow; // Use appropriate namespace

use Temporal\Workflow\WorkflowInterface;
use Temporal\Workflow\WorkflowMethod;
use Temporal\Activity\ActivityOptions;
use Temporal\Workflow;
use App\Activity\YourActivityInterface; // Assumes YourActivityInterface exists

#[WorkflowInterface]
interface YourWorkflowInterface
{
    #[WorkflowMethod]
    public function execute(string $name): \\Generator;
}

class YourWorkflow implements YourWorkflowInterface
{
    public function execute(string $name): \\Generator
    {
        Workflow::getLogger()->info('Workflow started', ['name' => $name]);
        // Workflow logic...
        // ... execute activities, timers, etc.
        return 'Workflow completed for ' . $name; // yield return for async
    }
}
?&gt;</code></pre>
                </div>
              </div>
          </article>

          <article id="workflow-constraints">
              <h3>Workflow Constraints (Determinism)</h3>
              <p>
              Workflow code must be deterministic. This means that given the same input and history, the code must
              always produce the same sequence of commands (like starting Activities or Timers). This allows the
              Temporal Cluster to replay the Workflow history and recover its state after failures.
              </p>
              <p>To maintain determinism:</p>
              <ul>
              <li>
                  <strong>No mutable global state:</strong> Avoid relying on or modifying variables outside the
                  Workflow's scope that could change between replays.
              </li>
              <li>
                  <strong>No direct external calls:</strong> Do not make network calls, file system access, or interact
                  with external systems directly from Workflow code. Use Activities for all side effects.
              </li>
              <li>
                  <strong>Deterministic randomness:</strong> If you need random numbers, use the SDK's deterministic
                  random functions (like <code>Workflow.newRandom()</code> in Java/Go, <code>workflow.random()</code> in Python/TS).
              </li>
              <li>
                  <strong>Deterministic time:</strong> Use the SDK's time functions (like <code>Workflow.currentTimeMillis()</code>
                  in Java, <code>Workflow.now()</code> in TS, <code>workflow.now()</code> in Python) instead of system time.
              </li>
              <li>
                  <strong>Deterministic iteration order:</strong> Avoid iterating over maps or dictionaries directly if the
                  order is not guaranteed. Convert them to sorted lists first if iteration order matters.
              </li>
              <li>
                  <strong>Avoid threading/goroutines (directly):</strong> Do not spawn threads or goroutines directly within
                  Workflow code. Use the SDK's mechanisms for concurrency if needed (like <code>Promise.all</code> in TS,
                  <code>Asyncio</code> primitives with <code>workflow.asyncio</code> in Python, <code>Workflow.go</code> in Go, <code>Async.function</code> in Java).
              </li>
              </ul>
              <p>
              Breaking these rules can lead to non-deterministic errors, which typically surface during replays or
              failovers and can be hard to debug. The SDK provides APIs (like Side Effects, `Workflow.getVersion`)
              to handle non-deterministic logic when absolutely necessary.
              </p>
          </article>
        </section>
        <!-- End Workflow Development Section -->

        <!-- Activity Development Section -->
        <section id="activity-development">
          <h2>Activity Development</h2>
          <p>
              Activities encapsulate the actual business logic, performing tasks like calling external services,
              interacting with databases, or processing data. They are executed by Workers and can be retried
              automatically.
          </p>

          <article id="activity-definition">
              <h3>Activity Definition</h3>
              <p>
              Define Activities using interfaces (Java, Go, PHP), functions (Python, TypeScript), or methods within
              classes (.NET).
              </p>

              <!-- Tabs for Activity Definition -->
              <div class="tab-container">
                  <div class="tab-buttons">
                      <button class="tab-button" data-tab-target="activity-def-ts">
                          TypeScript
                      </button>
                      <button class="tab-button" data-tab-target="activity-def-py">
                          Python
                      </button>
                      <button class="tab-button" data-tab-target="activity-def-go">
                          Go
                      </button>
                      <button class="tab-button" data-tab-target="activity-def-java">
                          Java
                      </button>
                      <button class="tab-button" data-tab-target="activity-def-dotnet">
                          .NET
                      </button>
                      <button class="tab-button" data-tab-target="activity-def-php">
                          PHP
                      </button>
                  </div>
                  <!-- Tab content divs moved inside tab-container -->
                  <div class="tab-content" id="activity-def-ts">
                      <h4>TypeScript</h4>
                      <p>
                          Define Activities as plain async functions. You can optionally group them in an object or class for
                          organization. Activity arguments and return types must be serializable by the configured Data
                          Converter (JSON by default). Use <code>Context.current().info</code> to access Activity information like Task Token.
                      </p>
                      <pre><code class="language-typescript">import { Context } from '@temporalio/activity';
import { log } from './logger'; // Assuming a configured logger

export async function composeGreeting(greeting: string, name: string): Promise&lt;string&gt; {
log.info('Activity input', { greeting, name });
const { activityId, workflowExecution } = Context.current().info;
log.info('Running in activity', { activityId, workflowId: workflowExecution.workflowId });

// Simulate external call or work
await new Promise((resolve) => setTimeout(resolve, 500));

return \`\${greeting}, \${name}!\`;
}

// Optional: Group activities
export const activities = { composeGreeting };</code></pre>
                  </div>

                  <div class="tab-content" id="activity-def-py">
                      <h4>Python</h4>
                      <p>
                          Define Activities using the <code>@activity.defn</code> decorator on functions. Activity arguments and return
                          types must be serializable (Defaults to JSON). Use <code>activity.info()</code> to access Activity
                          information.
                      </p>
                      <pre><code class="language-python">from temporalio import activity
import time

@activity.defn
def compose_greeting(greeting: str, name: str) -> str:
    activity.logger.info(f"Composing greeting for {name}")
    # Activity logic...
    time.sleep(0.5) # Simulate I/O
    return f"{greeting}, {name}!"

@activity.defn(name="DifferentActivityName")
async def do_async_work(value: int) -> int:
    activity.logger.info(f"Doing async work with {value}")
    # Async activity logic...
    await asyncio.sleep(1)
    return value * 10
</code></pre>
                  </div>

                  <div class="tab-content" id="activity-def-go">
                      <h4>Go</h4>
                      <p>
                          Define Activities as functions or methods on a struct. The function signature must include
                          <code>context.Context</code> as the first argument. Arguments and return values must be serializable (JSON by
                          default). Use <code>activity.GetInfo(ctx)</code> to access information.
                      </p>
                      <pre><code class="language-go">package app

import (
"context"
"fmt"
"time"

"go.temporal.io/sdk/activity"
"go.temporal.io/sdk/log"
)

// Simple function as Activity
func ComposeGreeting(ctx context.Context, greeting string, name string) (string, error) {
logger := activity.GetLogger(ctx)
logger.Info("Activity invoked", "greeting", greeting, "name", name)

info := activity.GetInfo(ctx)
logger.Info("Running activity", "ActivityID", info.ActivityID, "WorkflowID", info.WorkflowExecution.ID)

// Simulate work
time.Sleep(500 * time.Millisecond)

result := fmt.Sprintf("%s, %s!", greeting, name)
return result, nil
}

// --- Alternatively: Activities as struct methods ---
type MyActivities struct {
// Dependencies can be injected here (e.g., DB connection pool)
}

func (a *MyActivities) SendNotification(ctx context.Context, userID string, message string) error {
logger := activity.GetLogger(ctx)
logger.Info("Sending notification", "UserID", userID, "Message", message)
// ... logic to send notification ...
return nil
}
</code></pre>
                  </div>

                  <div class="tab-content" id="activity-def-java">
                      <h4>Java</h4>
                      <p>
                          Define an Activity interface annotated with <code>@ActivityInterface</code>. Each method in the
                          interface defines an Activity Type. Implement this interface.
                      </p>
                      <pre><code class="language-java">package your.application.activities; // Use your actual package name

import io.temporal.activity.ActivityInterface;
import io.temporal.activity.ActivityMethod;

@ActivityInterface
public interface YourActivities {
    // Default Activity name is "DoWork"
    String doWork(String input);

    // Explicitly named Activity
    @ActivityMethod(name = "ProcessPayment")
    boolean processPaymentActivity(String orderId, double amount);
}

// Implementation
public class YourActivitiesImpl implements YourActivities {
    @Override
    public String doWork(String input) {
        // Activity logic...
        return "Processed: " + input;
    }

    @Override
    public boolean processPaymentActivity(String orderId, double amount) {
        // Payment processing logic...
        System.out.printf("Processing payment for order %s, amount %.2f%n", orderId, amount);
        return true;
    }
}</code></pre>
                  </div>

                  <div class="tab-content" id="activity-def-dotnet">
                      <h4>.NET</h4>
                      <p>
                          Define Activity methods within any class, marking them with the <code>[Activity]</code> attribute.
                          Methods can be static or instance methods.
                      </p>
                      <pre><code class="language-csharp">using Temporalio.Activities;
using System.Threading.Tasks;

public class MyActivities
{
    [Activity]
    public async Task&lt;string&gt; ComposeGreetingAsync(string greeting, string name)
    {
        // Activity logic...
        Activity.Logger.LogInformation("Running activity with greeting {Greeting} and name {Name}", greeting, name);
        await Task.Delay(500); // Simulate work
        return $"{greeting}, {name}!";
    }

    [Activity("StaticActivity")] // Custom name
    public static string DoStaticWork(int value)
    {
        return $"Static result: {value * 2}";
    }
}</code></pre>
                  </div>

                  <div class="tab-content" id="activity-def-php">
                      <h4>PHP</h4>
                      <p>
                          Define an Activity interface annotated with <code>#[ActivityInterface]</code>. Each method defines an
                          Activity Type. Implement this interface.
                      </p>
                      <pre><code class="language-php">&lt;?php

namespace App\Activity;

use Temporal\Activity\ActivityInterface;
use Temporal\Activity\ActivityMethod;

#[ActivityInterface(prefix: "App.Activities.")] // Optional prefix for all activity names
interface YourActivityInterface
{
    public function composeGreeting(string $greeting, string $name): string;

    #[ActivityMethod("ExecutePayment")] // Custom name overrides prefix
    public function executePaymentActivity(string $transactionId): bool;
}

// Implementation
use Temporal\Activity;

class YourActivities implements YourActivityInterface
{
    public function composeGreeting(string $greeting, string $name): string
    {
        Activity::getLogger()->info("Composing greeting", ['greeting' => $greeting, 'name' => $name]);
        // Activity logic...
        return $greeting . ', ' . $name . '!';
    }

    public function executePaymentActivity(string $transactionId): bool
    {
        Activity::getLogger()->info("Executing payment", ['transactionId' => $transactionId]);
        // Payment logic...
        return true;
    }
}
?&gt;</code></pre>
                  </div>
              </div> <!-- End tab-container -->
          </article>

          <article id="activity-context">
              <h3>Activity Context and Information</h3>
              <p>
              Activities can access metadata about their current execution, such as the Workflow ID, Activity ID, Task
              Token (needed for asynchronous completion), and configured timeouts. This is typically done via a
              context object or static methods provided by the SDK. Logging within Activities should ideally use the
              SDK's logger, which automatically includes this contextual information.
              </p>
              <p>
              Example: Accessing Activity Info (Conceptual - specific methods vary by SDK as shown in definition examples)
              </p>
              <pre><code class="plaintext"># Inside an Activity...
activity_info = get_current_activity_info()
workflow_id = activity_info.workflow_id
activity_id = activity_info.activity_id
task_token = activity_info.task_token
attempt_number = activity_info.attempt
log("Starting activity", workflow_id=workflow_id, activity_id=activity_id, attempt=attempt_number)

# ... perform activity work ...

# If completing asynchronously later:
# save_task_token_somewhere(task_token)
# return special marker indicating async completion
</code></pre>
        </article>

        <article id="activity-registration">
            <h3>Activity Registration</h3>
            <p>
            Workers need to know which Activity implementations correspond to the Activity Types requested by
            Workflows. This is done by registering Activity implementations with the Worker.
            </p>

            <!-- Tabs for Activity Registration -->
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" data-tab-target="activity-reg-ts">
                        TypeScript
                    </button>
                    <button class="tab-button" data-tab-target="activity-reg-py">
                        Python
                    </button>
                    <button class="tab-button" data-tab-target="activity-reg-go">
                        Go
                    </button>
                    <button class="tab-button" data-tab-target="activity-reg-java">
                        Java
                    </button>
                    <button class="tab-button" data-tab-target="activity-reg-dotnet">
                        .NET
                    </button>
                    <button class="tab-button" data-tab-target="activity-reg-php">
                        PHP
                    </button>
                </div>
                <!-- Tab content divs moved inside tab-container -->
                <div class="tab-content" id="activity-reg-ts">
                    <h4>TypeScript</h4>
                    <p>Pass Activity functions (often grouped in an object) to <code>Worker.create</code>.</p>
                    <pre><code class="language-typescript">import { Worker } from '@temporalio/worker';
import * as activities from './activities'; // Assuming activities = { composeGreeting, ... }

async function run() {
const worker = await Worker.create({
    // ... connection, taskQueue, workflowsPath ...
    activities, // Register all exported functions from activities module
});
await worker.run();
}</code></pre>
                </div>

                <div class="tab-content" id="activity-reg-py">
                    <h4>Python</h4>
                    <p>Provide Activity functions decorated with <code>@activity.defn</code> to the <code>Worker</code> constructor.</p>
                    <pre><code class="language-python">from temporalio.worker import Worker
from temporalio.client import Client
# Assume activities.py defines compose_greeting, etc.
from activities import compose_greeting

async def main():
    client = await Client.connect("localhost:7233")
    worker = Worker(
        client,
        task_queue="my-task-queue",
        workflows=[GreetingWorkflow], # Assume GreetingWorkflow is defined
        activities=[compose_greeting], # Register activity functions
    )
    await worker.run()</code></pre>
                </div>

                <div class="tab-content" id="activity-reg-go">
                    <h4>Go</h4>
                    <p>Use <code>worker.RegisterActivity</code> or <code>worker.RegisterActivityWithOptions</code>.</p>
                    <pre><code class="language-go">import (
"go.temporal.io/sdk/client"
"go.temporal.io/sdk/worker"
// Assume app package defines ComposeGreeting and YourWorkflow
"your_module/app"
)

func main() {
c, _ := client.Dial(client.Options{})
defer c.Close()

w := worker.New(c, "my-task-queue", worker.Options{})

// Register Activity function
w.RegisterActivity(app.ComposeGreeting)

// Or register methods from a struct instance
// activityInstance := &app.MyActivities{}
// w.RegisterActivity(activityInstance)

w.RegisterWorkflow(app.YourWorkflow)

err := w.Run(worker.InterruptCh())
// Handle error
}</code></pre>
                </div>

                <div class="tab-content" id="activity-reg-java">
                    <h4>Java</h4>
                    <p>Register Activity implementation instances using <code>worker.registerActivitiesImplementations</code>.</p>
                    <pre><code class="language-java">import io.temporal.worker.WorkerFactory;
import io.temporal.worker.Worker;
import io.temporal.client.WorkflowClient;
import io.temporal.serviceclient.WorkflowServiceStubs;
// Assume YourActivitiesImpl and YourWorkflowImpl exist

public class WorkerMain {
    public static void main(String[] args) {
    WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();
    WorkflowClient client = WorkflowClient.newInstance(service);
    WorkerFactory factory = WorkerFactory.newInstance(client);

    Worker worker = factory.newWorker("my-task-queue");

    // Register Workflow implementation type
    worker.registerWorkflowImplementationTypes(YourWorkflowImpl.class);

    // Register Activity implementation instance(s)
    worker.registerActivitiesImplementations(new YourActivitiesImpl());

    factory.start();
    }
}</code></pre>
                </div>

                <div class="tab-content" id="activity-reg-dotnet">
                    <h4>.NET</h4>
                    <p>Add Activity classes to the Worker options via <code>AddActivity</code>.</p>
                    <pre><code class="language-csharp">using Temporalio.Client;
using Temporalio.Worker;
// Assume MyActivities and YourWorkflow exist

var client = await TemporalClient.ConnectAsync(new("localhost:7233"));

var workerOptions = new TemporalWorkerOptions("my-task-queue")
    .AddWorkflow&lt;YourWorkflow&gt;()
    .AddActivity(MyActivities.ComposeGreetingAsync) // Register specific static method
    .AddActivity(MyActivities.DoStaticWork)
    .AddActivities(new MyActivities()); // Register instance methods if needed

var worker = new TemporalWorker(client, workerOptions);

try {
    await worker.ExecuteAsync(CancellationToken.None); // Use cancellation token
} catch (Exception ex) {
    // Handle exception
}</code></pre>
                </div>

                <div class="tab-content" id="activity-reg-php">
                    <h4>PHP</h4>
                    <p>Register Activity implementation instances via <code>registerActivityImplementations</code>.</p>
                    <pre><code class="language-php">&lt;?php
use Temporal\\\\WorkerFactory;\nuse App\\\\YourWorkflow; // Assuming Workflow implementation\nuse App\\\\YourActivity; // Assuming Activity implementation\nuse Psr\\\\Log\\\\AbstractLogger; // For example logger\n\n// Simple logger implementation for the example\nclass SimpleLogger extends AbstractLogger {\n    public function log($level, $message, array $context = []): void { // Add void return type\n        echo \"LOG: $message\" . PHP_EOL; // Use PHP_EOL for line endings\n    }\n}\n\n$factory = WorkerFactory::create();\n$worker = $factory->newWorker(\'my-task-queue\');\n\n// Register Workflow implementation class\n$worker->registerWorkflowTypes(YourWorkflow::class);\n\n// Register Activity implementation instance(s)\n// Dependencies (like logger) can be injected here\n$worker->registerActivityImplementations(new YourActivity(new SimpleLogger()));\n\n$factory->run();
?&gt;</code></pre>
                </div>
            </div> <!-- End tab-container -->
        </article>

        <article id="start-worker">
            <h3>Start a Worker</h3>
            <p>
            Starting a Worker involves creating a Worker object configured with the Temporal Client connection, Task
            Queue name, and registered Workflow/Activity types, and then calling its run/start method.
            </p>
            <p>
            The run/start method typically blocks, continuously polling the Task Queue and executing tasks until the
            process is terminated or an explicit stop signal is received.
            </p>
            <pre><code class="plaintext"># Pseudocode for starting a worker
client = connect_to_temporal("localhost:7233")

worker = Worker(
  client=client,
  task_queue="your-task-queue-name",
  workflows=[YourWorkflowImplementation],
  activities=[your_activity_function_or_instance]
)

print("Starting Worker...")
worker.run() # Blocks until interrupted/stopped
print("Worker stopped.")
</code></pre>
        </article>

        <article id="worker-configuration">
            <h3>Worker Configuration</h3>
            <p>
            Workers offer various configuration options to tune performance, resource usage, and behavior:
            </p>
            <ul>
            <li>
                <strong>Max Concurrent Activities:</strong> Limits the number of Activity Tasks executed concurrently.
            </li>
            <li>
                <strong>Max Concurrent Workflow Tasks:</strong> Limits the number of Workflow Tasks executed
                concurrently.
            </li>
            <li>
                <strong>Task Queue Polling Intervals:</strong> Adjusts how frequently the Worker polls for tasks.
            </li>
            <li>
                <strong>Identity:</strong> Sets a custom identity for the Worker, visible in logs and UI. Useful for
                distinguishing between different Worker deployments.
            </li>
            <li>
                <strong>Sticky Execution Options:</strong> Configures the behavior of Workflow state caching (for example, cache size).
            </li>
            <li>
                <strong>Build ID / Versioning:</strong> Associates a Worker build/version identifier, enabling Worker Versioning features.
            </li>
            </ul>
            <p>
            Refer to the specific SDK documentation for the exact names and available options. Tuning these parameters
            is crucial for optimizing Worker performance based on workload characteristics and available resources. For example,
            I/O-bound Activities might benefit from higher concurrency, while CPU-bound Activities might require lower
            concurrency matching available cores.
            </p>
        </article>

        <article id="worker-shutdown">
            <h3>Worker Shutdown</h3>
            <p>
            Proper shutdown of Workers is important to ensure that in-progress tasks are handled gracefully.
            </p>
            <ul>
            <li>
                <strong>Graceful Shutdown:</strong> Most SDKs provide a way to initiate a graceful shutdown (for example, by
                canceling a context or calling a `stop` method). The Worker stops polling for new tasks and waits
                for a configurable period for existing tasks to complete.
            </li>
            <li>
                <strong>Activity Shutdown:</strong> Running Activities are typically allowed to complete or might be sent a
                cancellation request during graceful shutdown, depending on the SDK. Long-running Activities might need
                explicit handling for cancellation or heartbeating to detect shutdown signals.
            </li>
            <li>
                <strong>Workflow Task Shutdown:</strong> In-progress Workflow Tasks are usually completed quickly.
            </li>
            <li>
                <strong>Forced Shutdown:</strong> If tasks do not complete within the grace period, the Worker process
                exits. Any Activities that were running might need to rely on Temporal's timeouts and retries to be
                rescheduled on another Worker. Workflow Task failures are handled by rescheduling the task with a
                backoff.
            </li>
            </ul>
</article>
        </section>
      <!-- End Worker Development Section -->

      <!-- Temporal Client Section -->
      <section id="temporal-client">
        <h2>Temporal Client</h2>
        <p>
            The Temporal Client is the interface used by your application code (that isn't part of a Workflow or
            Activity) to interact with the Temporal Cluster. It allows you to start, signal, query, and manage
            Workflow Executions.
        </p>

        <article id="client-connection">
            <h3>Client Connection</h3>
            <p>
            Establish a connection to the Temporal Cluster, specifying the target address (host:port) of the Frontend
            Service. Options usually include configuring TLS, identity, namespace, and connection timeouts. It's
            recommended to create a single Client instance per application process and reuse it.
            </p>
            <pre><code class="plaintext"># Pseudocode for client connection
options = {
  target_host: "your-temporal-frontend.example.com:7233",
  namespace: "your-namespace", # Defaults typically to 'default'
  # tls_options: { ... } # Optional TLS config
}
client = TemporalClient.connect(options)

# Use the client instance throughout your application...

# Close connection when application exits
client.close()
</code></pre>
        </article>

        <article id="start-workflow-execution">
            <h3>Start a Workflow Execution</h3>
            <p>
            Use the Client to start a new Workflow Execution. Key parameters include:
            </p>
            <ul>
            <li>
                <strong>Workflow Type:</strong> The name or type identifying the Workflow definition registered with
                Workers.
            </li>
            <li>
                <strong>Task Queue:</strong> The Task Queue name that Workers processing this Workflow are listening on.
            </li>
            <li>
                <strong>Workflow ID:</strong> A unique business-level identifier for this specific execution (for example, order ID,
                user ID). Reusing a Workflow ID with a different run attempt results in a "Workflow execution already
                started" error unless specific policies are set.
            </li>
            <li>
                <strong>Arguments:</strong> The input arguments required by the Workflow function/method.
            </li>
            <li>
                <strong>Options:</strong> Workflow Execution Timeout, Workflow Run Timeout, Retry Policies, Memo, Search Attributes, etc.
            </li>
            </ul>

            <!-- Tabs for Starting Workflow -->
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" data-tab-target="start-wf-ts">
                        TypeScript
                    </button>
                    <button class="tab-button" data-tab-target="start-wf-py">
                        Python
                    </button>
                    <button class="tab-button" data-tab-target="start-wf-go">
                        Go
                    </button>
                    <button class="tab-button" data-tab-target="start-wf-java">
                        Java
                    </button>
                    <button class="tab-button" data-tab-target="start-wf-dotnet">
                        .NET
                    </button>
                    <button class="tab-button" data-tab-target="start-wf-php">
                        PHP
                    </button>
                </div>
                <!-- Tab content divs moved inside tab-container -->
                <div class="tab-content" id="start-wf-ts">
                    <h4>TypeScript</h4>
                    <pre><code class="language-typescript">import { Client } from '@temporalio/client';
import { exampleWorkflow } from './workflows'; // Assuming workflow function

async function runClient() { // Renamed to avoid conflict if run() is used elsewhere
    const client = new Client(); // Connects to localhost:7233 by default

    const handle = await client.workflow.start(exampleWorkflow, {
        taskQueue: 'my-task-queue',
        args: ['Temporal'], // Arguments for exampleWorkflow
        workflowId: 'workflow-' + Date.now(), // Unique ID
        // Optional: workflowExecutionTimeout: '5 minutes',
    });

    console.log(`Started workflow ${handle.workflowId}`);
    // const result = await handle.result(); // Wait for completion
}</code></pre>
                </div>

                <div class="tab-content" id="start-wf-py">
                    <h4>Python</h4>
                    <pre><code class="language-python">import asyncio
import uuid # For generating unique IDs
from temporalio.client import Client
from your_workflows import GreetingWorkflow # Assuming @workflow.defn class

async def start_workflow_client(): # Renamed for clarity
    client = await Client.connect("localhost:7233")

    handle = await client.start_workflow(
        GreetingWorkflow.run, # Reference the @workflow.run method
        "Temporal", # First arg for run method
        id="workflow-" + str(uuid.uuid4()), # Use UUID for uniqueness
        task_queue="my-task-queue",
        # Optional: execution_timeout=timedelta(minutes=5)
    )

    print(f"Started workflow {handle.id}")
    # result = await handle.result()</code></pre>
            </div>

            <div class="tab-content" id="start-wf-go">
            <h4>Go</h4>
            <pre><code class="language-go">package main // Assuming client code is in main package

import (
"context"
"log"
"time" // For Time
"github.com/pborman/uuid" // For UUIDs
"go.temporal.io/sdk/client"
"your_module/app" // Assuming app.YourWorkflow exists
)

func main() {
    c, err := client.Dial(client.Options{})
    if err != nil { log.Fatalln("Unable to create client", err) }
    defer c.Close()

    options := client.StartWorkflowOptions{
        ID:        "workflow-" + uuid.New(), // Use UUID for uniqueness
        TaskQueue: "my-task-queue",
        // WorkflowExecutionTimeout: 5 * time.Minute,
    }

    we, err := c.ExecuteWorkflow(context.Background(), options, app.YourWorkflow, "Temporal")
    if err != nil { log.Fatalln("Unable to execute workflow", err) }

    log.Println("Started workflow", "WorkflowID", we.GetID(), "RunID", we.GetRunID())

    // var result string
    // err = we.Get(context.Background(), &result) // Wait for completion
}</code></pre>
            </div>

            <div class="tab-content" id="start-wf-java">
            <h4>Java</h4>
            <pre><code class="language-java">package your.application; // Use your actual package name

import io.temporal.client.*;
import io.temporal.serviceclient.WorkflowServiceStubs;
import java.util.UUID; // For UUIDs
import your.application.workflows.YourWorkflow; // Assuming YourWorkflow interface exists

public class Starter {
    public static void main(String[] args) {
        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();
        WorkflowClient client = WorkflowClient.newInstance(service);

        WorkflowOptions options = WorkflowOptions.newBuilder()
            .setTaskQueue("my-task-queue")
            .setWorkflowId("workflow-" + UUID.randomUUID().toString()) // Use UUID
            // .setWorkflowExecutionTimeout(Duration.ofMinutes(5))
            .build();

        // Create a Workflow stub targeting the interface
        YourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, options);

        // Start execution asynchronously
        WorkflowExecution execution = WorkflowClient.start(workflow::execute, "Temporal");
        // The above is equivalent to:
        // CompletableFuture<String> result = WorkflowClient.execute(workflow::execute, "Temporal");


        System.out.println("Started workflow " + execution.getWorkflowId());

        // To wait for result (if using start):
        // String result = workflow.execute("Temporal"); // This blocks until completion
        // Or if using execute, use the CompletableFuture
    }
}</code></pre>
            </div>

            <div class="tab-content" id="start-wf-dotnet">
            <h4>.NET</h4>
            <pre><code class="language-csharp">using Temporalio.Client;
using System;
using System.Threading.Tasks;
using YourApplication.Workflows; // Assume YourApplication.Workflows.YourWorkflow exists

public class WorkflowStarter
{
    public static async Task StartWorkflowAsync() // Example method
    {
        var client = await TemporalClient.ConnectAsync(new("localhost:7233"));

        // Start using the Workflow class and run method signature
        WorkflowHandle&lt;YourWorkflow, string&gt; handle = await client.StartWorkflowAsync(
            (YourWorkflow wf) => wf.RunAsync("Temporal"), // Lambda targeting the run method
            new(id: "workflow-" + Guid.NewGuid(), taskQueue: "my-task-queue") // Use Guid
            {
                // ExecutionTimeout = TimeSpan.FromMinutes(5)
            });

        Console.WriteLine($"Started workflow {handle.Id}");

        // string result = await handle.GetResultAsync(); // Wait for completion
    }
}</code></pre>
            </div>

            <div class="tab-content" id="start-wf-php">
            <h4>PHP</h4>
            <pre><code class="language-php">&lt;?php declare(strict_types=1);\n\nnamespace App\\Client; // Use appropriate namespace\n\nuse Temporal\\Client\\WorkflowClientInterface;\nuse Temporal\\Client\\WorkflowOptions;\nuse App\\Workflow\\YourWorkflowInterface; // Assuming Workflow interface\nuse Ramsey\\Uuid\\Uuid; // Example: Use ramsey/uuid for UUIDs\n\n// Assume $workflowClient is initialized (e.g., via dependency injection)\n/** @var WorkflowClientInterface $workflowClient */\n\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withTaskQueue(\'my-task-queue\')\n        ->withWorkflowId(\'workflow-\' + Uuid::uuid4()->toString()) // Generate UUID\n    // ->withWorkflowExecutionTimeout(CarbonInterval::minutes(5))\n);\n\n$run = $workflowClient->start($workflow, \'Temporal\'); // Pass args for execute method\n\necho \"Started workflow \" . $run->getExecution()->id . \"\\n\";\n\n// $result = $run->getResult(); // Wait for completion\n?&gt;</code></pre>
            </div>
        </article>

        <article id="get-workflow-result">
            <h3>Get the Result of a Workflow Execution</h3>
            <p>
            After starting a Workflow, you can obtain a handle or stub representing that specific execution. You can
            use this handle to wait for the Workflow to complete and retrieve its return value or exception. This is
            typically a blocking call.
            </p>
            <pre><code class="plaintext"># Pseudocode for getting result
client = ...
workflow_handle = client.start_workflow(...)

print(f"Waiting for workflow {workflow_handle.id} to complete...")
try:
  # This blocks until the workflow finishes (completes, fails, times out, etc.)
  result = workflow_handle.get_result(timeout=300) # Optional timeout for the wait itself
  print(f"Workflow completed successfully with result: {result}")
except WorkflowFailedError as e:
  print(f"Workflow failed: {e.cause}")
except WorkflowTimedOutError:
  print("Workflow timed out")
# ... other potential exceptions like cancellation
</code></pre>
        </article>

        <article id="signal-workflows">
            <h3>Signal Workflows</h3>
            <p>
            Signals provide a way to send data asynchronously into a running Workflow Execution. Workflows define
            Signal handlers to process these incoming signals. Signals are durable and guaranteed to be delivered
            (at least once). They are often used for updates, notifications, or external events.
            </p>
            <p>Use the Client to send a signal:</p>
            <ul>
            <li>Identify the target Workflow Execution (by Workflow ID).</li>
            <li>Specify the Signal name (defined in the Workflow).</li>
            <li>Provide the Signal arguments.</li>
            </ul>
            <p>
            You can signal a Workflow even if you don't know if it's running yet using `signalWithStart`, which will
            start the Workflow if it doesn't exist and then immediately deliver the signal.
            </p>

            <!-- Tabs for Signaling -->
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" data-tab-target="signal-wf-ts">
                        TypeScript
                    </button>
                    <button class="tab-button" data-tab-target="signal-wf-py">
                        Python
                    </button>
                    <button class="tab-button" data-tab-target="signal-wf-go">
                        Go
                    </button>
                    <button class="tab-button" data-tab-target="signal-wf-java">
                        Java
                    </button>
                    <button class="tab-button" data-tab-target="signal-wf-dotnet">
                        .NET
                    </button>
                    <button class="tab-button" data-tab-target="signal-wf-php">
                        PHP
                    </button>
                </div>
                <!-- Tab content divs moved inside tab-container -->
                <div class="tab-content" id="signal-wf-ts">
                    <h4>TypeScript</h4>
                    <pre><code class="language-typescript">import { Client } from '@temporalio/client';
import { exampleWorkflow } from './workflows'; // Assuming workflow function with signals
// Assume workflow defines a signal handler named 'updateGreeting'

async function signalClient() { // Renamed for clarity
    const client = new Client();
    const handle = client.workflow.getHandle('workflow-id-123'); // Get handle by ID

    // Send signal
    await handle.signal('updateGreeting', 'Hi');
    console.log('Signal sent');

    // Signal with start: Starts if not running, otherwise signals.
    // const handle = await client.workflow.signalWithStart(exampleWorkflow, {
    //   taskQueue: 'my-task-queue',
    //   workflowId: 'unique-workflow-id',
    //   args: ['Initial Name'],
    //   signal: 'updateGreeting',
    //   signalArgs: ['Hi'],
    // });
}</code></pre>
                </div>

                <div class="tab-content" id="signal-wf-py">
                    <h4>Python</h4>
                    <pre><code class="language-python">import asyncio
from temporalio.client import Client
# Assume workflow defines @workflow.signal method 'update_greeting'

async def signal_workflow_client(): # Renamed for clarity
    client = await Client.connect("localhost:7233")
    handle = client.get_workflow_handle("workflow-id-123")

    # Send signal
    await handle.signal("update_greeting", "Hi")
    print("Signal sent")

    # Signal with start
    # handle = await client.signal_with_start_workflow(
    #     GreetingWorkflow.run, "Initial Name", # Workflow + args
    #     id="unique-workflow-id", task_queue="my-task-queue",
    #     signal="update_greeting", signal_args=["Hi"] # Signal + args
    # )</code></pre>
                </div>

                <div class="tab-content" id="signal-wf-go">
                    <h4>Go</h4>
                    <pre><code class="language-go">package main

import (
"context"
"log"
"go.temporal.io/sdk/client"
// Assume your workflow defines a signal named "UpdateGreeting"
// import "your_module/app"
)

func main() {
    c, _ := client.Dial(client.Options{})
    defer c.Close()

    workflowID := "workflow-id-123"
    signalName := "UpdateGreeting" // Matches name in Workflow definition
    signalArg := "Hi"

    // Send signal
    err := c.SignalWorkflow(context.Background(), workflowID, "", signalName, signalArg)
    if err != nil { log.Println("Error signaling workflow", err) } else { log.Println("Signal sent") }

    // Signal with start
    // workflowRun, err := c.SignalWithStartWorkflow(context.Background(),
    //    "unique-workflow-id", "my-task-queue",
    //    signalName, signalArg, // Signal and args
    //    client.StartWorkflowOptions{...}, // Workflow options
    //    app.YourWorkflow, "Initial Name", // Workflow function and args
    // )
}</code></pre>
                </div>

                <div class="tab-content" id="signal-wf-java">
                    <h4>Java</h4>
                    <pre><code class="language-java">package your.application;

import io.temporal.client.*;
import io.temporal.serviceclient.WorkflowServiceStubs;
import your.application.workflows.YourWorkflow; // Assume YourWorkflow interface defines a @SignalMethod void updateGreeting(String greeting);

public class Signaler {
    public static void main(String[] args) {
        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs(); // Example connection
        WorkflowClient client = WorkflowClient.newInstance(service);
        String workflowId = "workflow-id-123";

        // Create a stub for signaling, only needs the Workflow ID
        YourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);

        // Send signal (non-blocking)
        workflow.updateGreeting("Hi");
        System.out.println("Signal sent");

        // Signal with start: Use WorkflowStub options
        // WorkflowOptions startOptions = WorkflowOptions.newBuilder()
        //     .setTaskQueue("my-task-queue")
        //     .setWorkflowId("unique-workflow-id")
        //     .build();
        // YourWorkflow signalWithStartStub = client.newWorkflowStub(YourWorkflow.class, startOptions);
        // BatchRequest request = client.newSignalWithStartRequest();
        // request.add(signalWithStartStub::execute, "Initial Name"); // Add start
        // request.add(signalWithStartStub::updateGreeting, "Hi"); // Add signal
        // client.signalWithStart(request);
    }
}</code></pre>
                </div>

                <div class="tab-content" id="signal-wf-dotnet">
                    <h4>.NET</h4>
                    <pre><code class="language-csharp">using Temporalio.Client;
using System; // For Console
using System.Threading.Tasks;
using YourApplication.Workflows; // Assume YourWorkflow defines [WorkflowSignal] void UpdateGreeting(string greeting);

public class WorkflowSignaler
{
    public static async Task SignalWorkflowAsync() // Example method
    {
        var client = await TemporalClient.ConnectAsync(new("localhost:7233"));
        var handle = client.GetWorkflowHandle&lt;YourWorkflow&gt;("workflow-id-123"); // Specify workflow type if using lambda

        // Send signal via lambda targeting the signal method
        await handle.SignalAsync((YourWorkflow wf) => wf.UpdateGreeting("Hi"));
        Console.WriteLine("Signal sent");
        // ... existing code ...
    }
}</code></pre>
                </div>

                <div class="tab-content" id="signal-wf-php">
                    <h4>PHP</h4>
                    <pre><code class="language-php">&lt;?php declare(strict_types=1);\\\\n\\\\nnamespace App\\\\\\\\Client;\\\\n\\\\nuse Temporal\\\\\\\\Client\\\\\\\\WorkflowClientInterface;\\\\nuse App\\\\\\\\Workflow\\\\\\\\YourWorkflowInterface; // Assume YourWorkflowInterface defines a signal method updateGreeting(string $greeting)\\\\n\\\\n/** @var WorkflowClientInterface $workflowClient */\\\\n\\\\n// Use newWorkflowStub to get a stub targeting a specific Workflow ID\\\\n$workflowStub = $workflowClient->newWorkflowStub(YourWorkflowInterface::class, \\\\\"workflow-id-123\\\\\");\\\\n// Send the signal (this example requires the workflow to be running)
$workflowStub->updateGreeting(\\\"Hi From PHP Client!\\\");

echo \\\\\"Signal sent to workflow \\\\\" . $workflowStub->getWorkflowId() . \\\\\"\\\\n\\\\\";

?&gt;</code></pre>
                </div>
            </div> <!-- End tab-container -->
        </article>

        <article id="query-workflows">
            <h3>Query Workflows</h3>
            <p>
            Queries provide a synchronous way to fetch state from a running Workflow Execution without affecting its
            history. Workflows define Query handlers to respond to these requests. Queries are strongly consistent by
            default, meaning they reflect the state of the Workflow just before the query is processed.
            </p>
            <p>Use the Client to query a Workflow:</p>
            <ul>
            <li>Identify the target Workflow Execution (by Workflow ID).</li>
            <li>Specify the Query name (defined in the Workflow).</li>
            <li>Provide any Query arguments.</li>
            <li>Receive the Query result directly.</li>
            </ul>

            <!-- Tabs for Querying -->
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" data-tab-target="query-wf-ts">
                        TypeScript
                    </button>
                    <button class="tab-button" data-tab-target="query-wf-py">
                        Python
                    </button>
                    <button class="tab-button" data-tab-target="query-wf-go">
                        Go
                    </button>
                    <button class="tab-button" data-tab-target="query-wf-java">
                        Java
                    </button>
                    <button class="tab-button" data-tab-target="query-wf-dotnet">
                        .NET
                    </button>
                    <button class="tab-button" data-tab-target="query-wf-php">
                        PHP
                    </button>
                </div>
                <!-- Tab content divs moved inside tab-container -->
                <div class="tab-content" id="query-wf-ts">
                    <h4>TypeScript</h4>
                    <pre><code class="language-typescript">import { Client } from '@temporalio/client';
import { exampleWorkflow } from './workflows'; // Assuming workflow function with signals
// Assume workflow defines a query handler named 'getGreeting'

async function queryClient() { // Renamed for clarity
    const client = new Client();
    const handle = client.workflow.getHandle('workflow-id-123');

    // Send query
    const result = await handle.query('getGreeting');
    console.log(`Query result: ${result}`);
}</code></pre>
                </div>

                <div class="tab-content" id="query-wf-py">
                    <h4>Python</h4>
                    <pre><code class="language-python">import asyncio
from temporalio.client import Client
# Assume workflow defines @workflow.query method 'get_greeting'

async def query_workflow_client(): # Renamed for clarity
    client = await Client.connect("localhost:7233")
    handle = client.get_workflow_handle("workflow-id-123")

    # Send query
    result = await handle.query("get_greeting")
    print(f"Query result: {result}")</code></pre>
                </div>

                <div class="tab-content" id="query-wf-go">
                    <h4>Go</h4>
                    <pre><code class="language-go">package main

import (
"context"
"log"
"go.temporal.io/sdk/client"
// Assume your workflow defines a query named "GetGreeting"
)

func main() {
    c, _ := client.Dial(client.Options{})
    defer c.Close()

    workflowID := "workflow-id-123"
    queryName := "GetGreeting" // Matches name in Workflow definition

    // Send query
    resp, err := c.QueryWorkflow(context.Background(), workflowID, "", queryName)
    if err != nil {
        log.Println("Error querying workflow", err)
    } else {
        var result string
        if err := resp.Get(&result); err != nil {
            log.Println("Error getting query result", err)
        } else {
            log.Println("Query result:", result)
        }
    }

    // Strongly Consistent Query (default): Waits for WF to process query
    // Eventually Consistent Query: May return slightly stale data from cache faster
    // resp, err := c.QueryWorkflowWithOptions(ctx, &client.QueryWorkflowWithOptionsRequest{
    //    WorkflowID: workflowID,
    //    QueryType: queryName,
    //    QueryConsistencyLevel: enums.QUERY_CONSISTENCY_LEVEL_EVENTUAL,
    // })
}</code></pre>
                </div>

                <div class="tab-content" id="query-wf-java">
                    <h4>Java</h4>
                    <pre><code class="language-java">package your.application;

import io.temporal.client.*;
import io.temporal.serviceclient.WorkflowServiceStubs;
import your.application.workflows.YourWorkflow; // Assume YourWorkflow interface defines @QueryMethod String getGreeting();

public class Querier {
    public static void main(String[] args) {
        WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs(); // Example connection
        WorkflowClient client = WorkflowClient.newInstance(service);
        String workflowId = "workflow-id-123";

        // Create a stub for querying
        YourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);

        // Send query (blocking)
        try {
            String result = workflow.getGreeting();
            System.out.println("Query result: " + result);
        } catch (WorkflowQueryException e) {
            System.err.println("Error querying workflow: " + e.getMessage());
        }
    }
}</code></pre>
                </div>

                <div class="tab-content" id="query-wf-dotnet">
                    <h4>.NET</h4>
                    <pre><code class="language-csharp">using Temporalio.Client;
using System; // For Console
using System.Threading.Tasks;
using YourApplication.Workflows; // Assume YourWorkflow defines [WorkflowQuery] string GetGreeting();

public class WorkflowQuerier
{
    public static async Task QueryWorkflowAsync() // Example method
    {
        var client = await TemporalClient.ConnectAsync(new("localhost:7233"));
        var handle = client.GetWorkflowHandle&lt;YourWorkflow&gt;("workflow-id-123"); // Specify workflow type for lambda

        // Send query via lambda targeting the query method
        string result = await handle.QueryAsync((YourWorkflow wf) => wf.GetGreeting());
        Console.WriteLine($"Query result: {result}");
        // ... existing code ...
    }
}</code></pre>
                </div>

                <div class="tab-content" id="query-wf-php">
                    <h4>PHP</h4>
                    <pre><code class="language-php">&lt;?php declare(strict_types=1);\\\\n\\\\nnamespace App\\\\\\\\Client;\\\\n\\\\nuse Temporal\\\\\\\\Client\\\\\\\\WorkflowClientInterface;\\\\nuse App\\\\\\\\Workflow\\\\\\\\YourWorkflowInterface; // Assume YourWorkflowInterface defines a query method getGreeting()\\\\n\\\\n/** @var WorkflowClientInterface $workflowClient */\\\\n\\\\n$workflowStub = $workflowClient->newWorkflowStub(YourWorkflowInterface::class, \\\\\"workflow-id-123\\\\\");\\\\n
// Send the query (blocking)
$result = $workflowStub->getGreeting();

echo \\\\\"Query result: \\\\\" . $result . \\\\\"\\\\n\\\\\";

?&gt;</code></pre>
                </div>
            </div> <!-- End tab-container -->
        </article>

        <!-- Moved Cancel and Terminate articles here, outside the tab structures -->
        <article id="terminate-workflows">
            <h3>Terminate Workflows</h3>
            <p>
            Terminating a Workflow Execution stops it immediately and forcefully. It will not execute any further
            logic or cleanup activities. Use termination with caution, typically for administrative purposes or when
            a Workflow is known to be in an unrecoverable state. Signals or Cancellations are generally preferred
            for graceful shutdown.
            </p>
            <pre><code class="plaintext"># Pseudocode for termination
client = ...
workflow_handle = client.get_workflow_handle("workflow-id-to-terminate")

try:
  await workflow_handle.terminate(reason="Admin cleanup")
  print("Workflow terminated.")
except Exception as e:
  print(f"Failed to terminate workflow: {e}") # e.g., workflow already completed
</code></pre>
        </article>

        <article id="cancel-workflows">
            <h3>Cancel Workflows</h3>
            <p>
            Cancellation is a cooperative mechanism. Requesting cancellation sends a cancellation request to the
            Workflow Execution. The Workflow code must explicitly check for cancellation requests (usually via SDK
            mechanisms like Cancellation Scopes or checking context) and decide how to handle them (for example, perform
            cleanup Activities, then exit gracefully). If the Workflow ignores the request, it continues running.
            </p>
            <pre><code class="plaintext"># Pseudocode for cancellation request
client = ...
workflow_handle = client.get_workflow_handle("workflow-id-to-cancel")

try:
  await workflow_handle.cancel()
  print("Cancellation requested.")
  # Note: Workflow might take time to actually handle the cancellation
except Exception as e:
  print(f"Failed to request cancellation: {e}")
</code></pre>
        </article>

      </section>
      <!-- End Temporal Client Section -->

      <!-- Advanced Concepts Section -->
      <section id="advanced-concepts">
        <h2>Advanced Concepts</h2>

        <article id="activity-heartbeating">
            <h3>Activity Heartbeating</h3>
            <p>
            For long-running Activities, Heartbeating allows the Activity to report its progress and liveness back to
            the Temporal Cluster. This serves several purposes:
            </p>
            <ul>
            <li>
                <strong>Liveness Detection:</strong> If the Cluster doesn't receive a heartbeat within the configured
                <code>HeartbeatTimeout</code>, it assumes the Activity Worker has crashed and reschedules the Activity (respecting
                the Retry Policy).
            </li>
            <li>
                <strong>Progress Checkpointing:</strong> Activities can include details (payload) with the heartbeat,
                effectively checkpointing their progress. If the Activity is retried (on the same or different
                Worker), it can retrieve the last checkpointed details from the Activity context and resume from that
                point, avoiding redundant work.
            </li>
            <li>
                <strong>Cancellation Check:</strong> The heartbeat mechanism also allows the Activity to check if a
                cancellation has been requested for the Workflow or the Activity itself. The Activity can then perform
                cleanup and exit gracefully.
            </li>
            </ul>
            <p>
            Heartbeating is crucial for Activities that might run longer than the <code>StartToCloseTimeout</code> or for tasks where
            reporting progress is beneficial. It's implemented by calling a specific SDK function (for example, <code>activity.RecordHeartbeat(ctx, details...)</code>) periodically within the Activity code.
            </p>
            <pre><code class="plaintext"># Pseudocode for Activity with Heartbeating
@activity.defn
async def long_running_task(input_data):
    progress = load_progress_from_details(activity.info().heartbeat_details)
    if progress is None:
        progress = 0

    total_items = len(input_data)
    for i in range(progress, total_items):
        # Check for cancellation before/during work
        activity.heartbeat(i) # Report progress (item 'i' is about to be processed)

        # Process item i...
        await asyncio.sleep(1) # Simulate work

        # Optional: Heartbeat again after processing item, if fine-grained needed
        # activity.heartbeat(i + 1)

    return "All items processed"

def load_progress_from_details(details):
    # Logic to interpret details sent with previous heartbeat
    if details: return details # Assuming details itself is the progress marker
    return None
</code></pre>
        </article>

        <article id="activity-async-completion">
            <h3>Complete Activities Asynchronously</h3>
            <p>
            In some scenarios, the process that completes an Activity might be different from the one that started it.
            For example, an Activity might trigger an external system (via API call) and rely on a webhook callback to
            signal completion.
            </p>
            <p>To handle this:</p>
            <ol>
            <li>
                The Activity obtains its unique <code>TaskToken</code> from the Activity Context. The Task Token identifies this
                specific Activity execution attempt.
            </li>
            <li>
                The Activity returns control to the Worker *without* completing, typically by throwing/returning a
                special indicator (like <code>activity.DoNotCompleteOnReturn</code> or a specific exception type).
            </li>
            <li>
                The Activity passes the <code>TaskToken</code> to the external system or process that will eventually signal
                completion.
            </li>
            <li>
                When the external process finishes, it uses a Temporal Client method (like <code>CompleteActivityById</code> or
                <code>CompleteActivity</code>, providing the Task Token) to report the result or failure back to the Temporal
                Cluster.
            </li>
            </ol>
            <p>
            The Worker that originally executed the Activity does not need to be running for the completion call to
            succeed. The Temporal Cluster uses the Task Token to correlate the completion call with the correct
            Workflow Execution.
            </p>
            <pre><code class="plaintext"># Pseudocode for Activity triggering async completion

@activity.defn
async def trigger_external_job(job_params):
    info = activity.info()
    task_token_str = info.task_token.decode('utf-8') # Get task token as string

    # Call external system, passing task_token_str as a callback identifier
    external_api.start_job(job_params, callback_token=task_token_str)

    # Tell the Worker not to complete this Activity yet
    activity.do_not_complete_on_return()


# --- Elsewhere, in a separate process (e.g., webhook handler) ---

def handle_external_job_completion(callback_token, result, error):
    client = connect_to_temporal() # Connect with a Temporal client
    task_token_bytes = callback_token.encode('utf-8')

    try:
        if error:
            client.report_activity_failure(task_token_bytes, error)
        else:
            client.report_activity_completion(task_token_bytes, result)
    except Exception as e:
        # Handle potential errors reporting completion (e.g., activity timed out already)
        log.error(f"Failed to report activity completion/failure for token {callback_token}: {e}")

</code></pre>
        </article>

        <article id="activity-cancellation">
            <h3>Activity Cancellation</h3>
            <p>
            Activities can be cancelled in two main ways:
            </p>
            <ol>
            <li>
                <strong>Workflow Cancellation:</strong> If the Workflow Execution that invoked the Activity is cancelled,
                the Temporal Cluster propagates the cancellation request to running Activities (depending on the
                Workflow's cancellation handling logic and SDK Cancellation Scopes).
            </li>
            <li>
                <strong>Activity Timeouts:</strong> If an Activity exceeds its <code>StartToCloseTimeout</code> or <code>ScheduleToCloseTimeout</code>,
                it is effectively cancelled by the timeout mechanism, and a failure is reported to the Workflow (which
                may trigger retries).
            </li>
            </ol>
            <p>
            Activities that need to perform cleanup when cancelled (for example, releasing a lock, rolling back a transaction)
            should check for cancellation requests. This is often done:
            </p>
            <ul>
            <li>Implicitly during <code>activity.RecordHeartbeat</code> calls.</li>
            <li>Explicitly using SDK context cancellation checks (for example, <code>ctx.Err()</code> in Go, checking <code>Activity.Current.CancellationToken.IsCancellationRequested</code> in .NET, checking <code>activity.is_cancelled()</code> in Python).</li>
            </ul>
            <p>
            Upon detecting cancellation, the Activity should perform its cleanup and then typically throw a specific
            cancelled exception type provided by the SDK.
            </p>
        </article>

        <article id="workflow-versioning">
            <h3>Workflow Versioning (Patching)</h3>
            <p>
            Since Workflow code must be deterministic, deploying updated Workflow code that changes the sequence of
            commands (like adding a new Activity call, removing a Timer) can break replays of existing, in-flight
            Workflow Executions that were started with the old code.
            </p>
            <p>
            The <code>Workflow.getVersion</code> API (or equivalent in each SDK) allows you to safely deploy changes to
            Workflow definitions without breaking compatibility.
            </p>
            <ol>
            <li>
                Wrap the new or modified logic within a <code>getVersion</code> block, assigning it a unique change ID (often an
                integer or descriptive string).
            </li>
            <li>
                Specify a default version (typically associated with the original code path) and the new version
                (associated with the changed code path).
            </li>
            <li>
                When a Worker executes this code during a replay: If the history already contains a marker for this
                change ID, the SDK automatically executes the code path corresponding to the recorded version.
            </li>
            <li>
                When a Worker executes this code for the *first time* (not a replay for this specific part), it
                executes the code associated with the *new* version you specified and records that version marker in the
                history.
            </li>
            </ol>
            <p>
            This ensures that existing executions continue deterministically along their original path, while new
            executions (or executions reaching this point for the first time) use the updated logic.
            </p>
            <pre><code class="plaintext"># Pseudocode for using getVersion

# --- Original Code ---
# result = await workflow.execute_activity(activity_A, ...)

# --- Updated Code ---
# We want to optionally call activity_B before activity_A

# Change ID identifies this specific patch/change
patch_change_id = "add-activity-B-call-v1"

# Default version (original behavior) is -1 (or some SDK-specific default)
# New version is 1 (or the next sequential number for this change ID)
version = workflow.get_version(patch_change_id, default=-1, max_supported=1)

if version == 1:
    # New code path: Call B first
    await workflow.execute_activity(activity_B, ...)

# Code common to both versions (or the original path if version == -1)
result = await workflow.execute_activity(activity_A, ...)

</code></pre>
            <p>
            After all in-flight Workflows using the old code path (default version) have completed, you can remove
            the <code>getVersion</code> call and the old code path, simplifying the Workflow definition.
            </p>
            <p>
            <strong>Note:</strong> Build ID based Worker Versioning is a newer, often preferred approach for managing incompatible Worker code deployments, especially across multiple Task Queues or complex rollouts. Patching is useful for targeted, small changes within a single Workflow definition.
            </p>
        </article>


        <article id="child-workflows">
            <h3>Execute Child Workflows</h3>
            <p>
            Workflows can start other Workflows, known as Child Workflows. This allows for modular design, breaking
            down complex business processes into smaller, reusable, and independently testable units.
            </p>
            <p>Key characteristics of Child Workflows:</p>
            <ul>
            <li>
                <strong>Independent History:</strong> Each Child Workflow has its own separate event history.
            </li>
            <li>
                <strong>Parent Relationship:</strong> The parent Workflow can track the status of the child and receive
                its result upon completion.
            </li>
            <li>
                <strong>Cancellation Propagation:</strong> Cancellation can be configured to propagate from parent to
                child (or not).
            </li>
            <li>
                <strong>Retries and Timeouts:</strong> Child Workflows have their own timeouts and retry policies,
                independent of the parent.
            </li>
            <li>
                <strong>Task Queues:</strong> Child Workflows can run on the same or different Task Queues as the parent.
            </li>
            </ul>
            <p>
            Starting a Child Workflow is similar to starting a Workflow via the Client, but it's done from within the
            parent Workflow's code using specific SDK functions (for example, <code>workflow.ExecuteChildWorkflow</code>). Options
            control the parent-child relationship behavior (for example, what happens if the parent completes before the
            child).
            </p>

            <!-- Tabs for Child Workflows -->
            <div class="tab-container">
            <button class="tab-button" data-tab-target="child-wf-ts">
                TypeScript
            </button>
            <button class="tab-button" data-tab-target="child-wf-py">
                Python
            </button>
            <button class="tab-button" data-tab-target="child-wf-go">
                Go
            </button>
            <button class="tab-button" data-tab-target="child-wf-java">
                Java
            </button>
            <button class="tab-button" data-tab-target="child-wf-dotnet">
                .NET
            </button>
            <button class="tab-button" data-tab-target="child-wf-php">
                PHP
            </button>
            </div>

            <div class="tab-content" id="child-wf-ts">
            <h4>TypeScript</h4>
            <pre><code class="language-typescript">import { executeChild, proxyActivities, ParentClosePolicy, workflowInfo } from '@temporalio/workflow'; // Import workflowInfo
import { childWorkflow } from './child'; // Assume childWorkflow definition exists

export async function parentWorkflow(name: string): Promise&lt;string&gt; {
    // Start child and wait for result
    const result = await executeChild(childWorkflow, {
        args: [name],
        workflowId: `child-${workflowInfo().workflowId}`, // Ensure unique child ID using workflowInfo
        // Default: ParentClosePolicy.TERMINATE (terminates child if parent closes)
        // Use ABANDON if child should continue after parent finishes
        parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON,
    });
    return `Parent received: ${result}`;
}</code></pre>
            </div>

            <div class="tab-content" id="child-wf-py">
            <h4>Python</h4>
            <pre><code class="language-python">from temporalio import workflow
from temporalio.common import ParentClosePolicy
# Assume child_workflow is defined in another file/module
with workflow.unsafe.imports_passed_through():
    from child_workflows import ChildWorkflow

@workflow.defn
class ParentWorkflow:
    @workflow.run
    async def run(self, name: str) -> str:
        result = await workflow.execute_child_workflow(
            ChildWorkflow.run,
            f"Input for {name}",
            id=f"child-{workflow.info().workflow_id}",
            parent_close_policy=ParentClosePolicy.ABANDON,
        )
        return f"Parent received: {result}"
</code></pre>
            </div>

            <div class="tab-content" id="child-wf-go">
            <h4>Go</h4>
            <pre><code class="language-go">package app // Assuming parent workflow is in app package

import (
"fmt" // For string formatting
"go.temporal.io/sdk/workflow"
"go.temporal.io/api/enums/v1"
// Assume app defines ChildWorkflow function
"your_module/app"
)

func ParentWorkflow(ctx workflow.Context, name string) (string, error) {
    cwo := workflow.ChildWorkflowOptions{
        // Generate a unique ID, e.g., combining parent ID and a unique part
        WorkflowID: fmt.Sprintf("child-%s-%s", workflow.GetInfo(ctx).WorkflowExecution.ID, workflow.GetRandomUUID(ctx)),
        ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,
    }
    ctx = workflow.WithChildOptions(ctx, cwo)

    var result string
    // Assuming ChildWorkflow is defined in the same package or imported correctly
    future := workflow.ExecuteChildWorkflow(ctx, app.ChildWorkflow, name)
    if err := future.Get(ctx, &result); err != nil {
        // Handle child workflow error (e.g., log, return error)
        workflow.GetLogger(ctx).Error("Child workflow failed", "Error", err)
        return "", err
    }
    return "Parent received: " + result, nil
}

// Assume ChildWorkflow definition exists, e.g.:
// func ChildWorkflow(ctx workflow.Context, inputName string) (string, error) {
//     workflow.GetLogger(ctx).Info("Child workflow started", "Input", inputName)
//     return "Result from child for " + inputName, nil
// }

</code></pre>
            </div>

            <div class="tab-content" id="child-wf-java">
            <h4>Java</h4>
            <pre><code class="language-java">package your.application.workflows; // Use your actual package name

import io.temporal.workflow.*;
import io.temporal.api.enums.v1.ParentClosePolicy;
import java.util.UUID; // For UUIDs
// Assume ChildWorkflow interface exists in the same package or imported

public class ParentWorkflowImpl implements ParentWorkflow { // Assuming ParentWorkflow interface
    @Override
    public String execute(String name) {
        ChildWorkflowOptions options = ChildWorkflowOptions.newBuilder()
            .setWorkflowId("child-" + Workflow.getInfo().getWorkflowId() + "-" + UUID.randomUUID().toString()) // Ensure unique ID
            .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)
            .build();

        ChildWorkflow child = Workflow.newChildWorkflowStub(ChildWorkflow.class, options);

        // Start child and wait for result
        String result = child.execute("Input for " + name);
        return "Parent received: " + result;

        // To start asynchronously:
        // Promise<String> promise = Async.function(child::execute, "Input for " + name);
        // Use promise.get() later
    }
}</code></pre>
            </div>

            <div class="tab-content" id="child-wf-dotnet">
            <h4>.NET</h4>
            <pre><code class="language-csharp">using Temporalio.Workflows;
using Temporalio.Common; // For ParentClosePolicy
using System; // For Guid
using System.Threading.Tasks;
using YourApplication.Workflows; // Assuming ChildWorkflow class exists in the same namespace or imported

[Workflow]
public class ParentWorkflow
{
    [WorkflowRun]
    public async Task&lt;string&gt; RunAsync(string name)
    {
        string result = await Workflow.ExecuteChildWorkflowAsync(
            (ChildWorkflow wf) => wf.RunChildAsync($"Input for {name}"), // Ensure RunChildAsync exists on ChildWorkflow
            new ChildWorkflowOptions
            {
                WorkflowId = $"child-{Workflow.Info.WorkflowId}-{Guid.NewGuid()}", // Ensure unique ID
                ParentClosePolicy = ParentClosePolicy.Abandon,
            }
        );
        return $"Parent received: {result}";
    }
}</code></pre>
            </div>

            <div class="tab-content" id="child-wf-php">
            <h4>PHP</h4>
            <pre><code class="language-php">&lt;?php declare(strict_types=1);\\\\n\\\\nnamespace App\\\\\\\\Workflow;\\\\n\\\\nuse Temporal\\\\\\\\Workflow\\\\\\\\ParentWorkflowInterface;\\\\nuse Temporal\\\\\\\\Workflow\\\\\\\\ParentWorkflowMethod;\\\\nuse Temporal\\\\\\\\Activity\\\\\\\\ActivityOptions;\\\\nuse Temporal\\\\\\\\Common\\\\\\\\RetryOptions;\\\\nuse Temporal\\\\\\\\Activity\\\\\\\\ActivityMethod;\\\\nuse Temporal\\\\\\\\Activity\\\\\\\\ActivityInterface;\\\\nuse App\\\\\\\\ChildWorkflows\\\\\\\\ChildWorkflow;\\\\nuse Ramsey\\\\Uuid\\\\Uuid; // Example: Use ramsey/uuid\\\\n\\\\n// Define ParentWorkflow interface and implementation\\\\ninterface ParentWorkflowInterface extends ParentWorkflowInterface&lt;?&gt; {\\\n    @ParentWorkflowMethod(name = "ParentWorkflow")\\\n    void execute(String name);\n}\\\n\\\\nclass ParentWorkflowImpl implements ParentWorkflowInterface {\\\n    @Override\\\n    @ParentWorkflowMethod(name = "ParentWorkflow")\\\n    public void execute(String name) {\\\n        // Start child workflow\\\n        ChildWorkflow.start(\\\"child-workflow\\\", [\\\"name\\\" => $name]);\\\\\n        // You can also use a different workflow ID if needed\\\\\n    }\\\\\n}\\\n?&gt;</code></pre>
            </div>
        </article>

        <article id="continue-as-new">
            <h3>Continue-As-New</h3>
            <p>
            Workflow Executions have limits on their event history size and duration. For very long-running processes
            or Workflows that accumulate a large history (for example, loops processing many items), `Continue-As-New` allows
            a Workflow to effectively restart itself with a fresh history, carrying over necessary state.
            </p>
            <p>When a Workflow decides to `Continue-As-New`:</p>
            <ol>
            <li>It specifies the same Workflow Type (or potentially a different one).</li>
            <li>It provides the input arguments for the *new* execution. This is how state is carried over.</li>
            <li>The current execution is marked as `ContinuedAsNew`.</li>
            <li>A new Workflow Execution starts immediately with the provided arguments and a clean history, but
                logically continues the business process. The Run ID changes, but the Workflow ID can be kept the same.
            </li>
            </ol>
            <p>
            This is the standard pattern for implementing infinite loops or processes that need to run indefinitely
            without hitting history limits. It's also useful for periodic cleanup of large state within a Workflow.
            </p>
            <pre><code class="plaintext"># Pseudocode for Continue-As-New loop

@workflow.defn
class PerpetualWorkflow:
    @workflow.run
    async def run(self, counter: int, other_state: dict = None): # Example with state
        if other_state is None:
            other_state = {} # Initialize state if first run

        workflow.logger.info(f"Executing run {counter} with state: {other_state}")

        # Example condition to ContinueAsNew (e.g., every 1000 iterations)
        if counter > 0 and counter % 1000 == 0:
            workflow.logger.info(f"Processed {counter} items, continuing as new...")
            # Carry over the necessary state to the new execution
            # Only include state needed for the *next* run
            workflow.continue_as_new(counter, other_state) # Restarts run() with new args
            # Note: Code after continue_as_new does not execute in the current run

        # --- Regular Workflow Logic ---
        workflow.logger.info(f"Processing item {counter}")
        # Do work... update other_state if needed
        # await workflow.execute_activity(process_item, counter, other_state, ...)
        other_state['last_processed'] = counter
        await workflow.sleep(timedelta(seconds=1)) # Simulate work or delay

        # "Loop" by calling continue_as_new with updated state for the next iteration
        workflow.continue_as_new(counter + 1, other_state)

# Client side starting the workflow for the first time:
    async def run(self, counter: int):
        if counter >= 1000: # Example condition to ContinueAsNew
            print(f"Processed {counter} items, continuing as new...")
            # Carry over the counter state to the new execution
            workflow.continue_as_new(counter) # Restarts run() with counter
        else:
            print(f"Processing item {counter}")
            # Do work...
            await workflow.execute_activity(process_item, counter, ...)

            # Schedule next iteration after a delay
            await workflow.sleep(timedelta(seconds=10))
            # "Loop" by calling continue_as_new with updated state
            workflow.continue_as_new(counter + 1)
</code></pre>
        </article>

        <article id="side-effects">
            <h3>Side Effects</h3>
            <p>
            While Workflows must be deterministic, sometimes you need to execute a short, non-deterministic piece of
            code within the Workflow logic itself (without calling an Activity). A common example is generating a UUID
            or getting a random number using a non-SDK function (which would violate determinism if called directly).
            </p>
            <p>
            <code>Workflow.SideEffect</code> (or equivalent) allows this.
            </p>
            <ol>
            <li>You provide a function/lambda containing the non-deterministic code to <code>SideEffect</code>.</li>
            <li>The first time this code path is executed, the function is run, and its return value is recorded in the
                Workflow history.</li>
            <li>During replays, the function is *not* re-executed. Instead, the recorded value from the history is
                returned directly, preserving determinism.</li>
            </ol>
            <p>
            Side Effects should only be used for short, simple operations where creating a dedicated Activity would be
            overkill. They are not suitable for I/O or long-running computations. For example, generating a unique ID or
            calling a potentially flaky function that you don't want to retry as a full Activity.
            </p>
            <pre><code class="plaintext"># Pseudocode for Side Effect

@workflow.defn
class MyWorkflow:
    @workflow.run
    async def run(self):
        # Generate a random ID using a potentially non-deterministic library function
        # This lambda is only executed once per execution path.
        random_id = await workflow.side_effect(lambda: generate_random_id_maybe_impure())

        # Use the random_id, which is now deterministic for replays
        await workflow.execute_activity(use_id_activity, random_id, ...)

        return f"Processed with ID: {random_id}"

# Note: For truly random values needed within workflow logic,
# prefer the SDK's deterministic random functions like workflow.random().
# SideEffect is more for integrating short non-deterministic external code.
</code></pre>
        </article>

        <article id="local-activities">
            <h3>Local Activities</h3>
            <p>
            Local Activities are an optimization for very short-lived Activities that don't require the full overhead
            of Task Queue polling, scheduling, and retries managed by the Temporal Cluster. They execute directly
            within the Worker's Workflow Task processing thread.
            </p>
            <p>Characteristics:</p>
            <ul>
            <li>
                <strong>Execution:</strong> Run in the same process as the Workflow code that called them.
            </li>
            <li>
                <strong>Latency:</strong> Much lower invocation latency compared to standard Activities (sub-millisecond).
            </li>
            <li>
                <strong>Retries:</strong> Limited, server-side retries are not applicable. Retries must be handled by the
                Workflow code itself or rely on the Workflow Task retry mechanism. A short, configurable local retry policy might be available in the SDK.
            </li>
            <li>
                <strong>Timeouts:</strong> Subject to shorter, locally configured timeouts, often tied to the Workflow
                Task timeout.
            </li>
            <li>
                <strong>Use Cases:</strong> Ideal for simple functions like data validation, transformation, short calculations,
                or accessing read-only resources local to the Worker, where the overhead of a standard Activity is
                undesirable. For example, validating input against a schema loaded in Worker memory.
            </li>
            <li>
                <strong>Determinism:</strong> Like standard Activities, Local Activities themselves do not need to be
                deterministic, but their *invocation* from the Workflow must be.
            </li>
            </ul>
            <p>
            Executing a Local Activity uses a specific SDK function (for example, <code>workflow.ExecuteLocalActivity</code>), often
            requiring different, shorter timeout configurations than standard Activities.
            </p>
        </article>

        <article id="mutations">
            <h3>Mutations</h3>
            <p>
            The <code>Workflow.upsertMemo</code>, <code>Workflow.upsertSearchAttributes</code> APIs allow Workflows to update their own Memo and
            Search Attributes during execution. These updates are recorded in the event history.
            </p>
            <p>
            <code>Workflow.deprecatePatch</code> is used in conjunction with <code>Workflow.getVersion</code> for managing code cleanup. Once you are
            sure no running Workflows are using an old code path identified by a specific change ID (patch ID), you
            can call `deprecatePatch(patch_change_id)`. This signals to the system (and potentially linting tools)
            that this patch ID is obsolete and its corresponding `getVersion` block can eventually be removed from the
            code.
            </p>
        </article>
      </section>
      <!-- End Advanced Concepts Section -->

      <!-- Testing Section -->
      <section id="testing">
        <h2>Testing</h2>
        <p>
            Testing Temporal applications is crucial for ensuring correctness and reliability. Temporal provides
            several mechanisms and recommendations for testing different aspects of your application, from individual
            Activities and Workflows in isolation to their integrated behavior.
        </p>

        <article id="testing-overview">
            <h3>Approaches to Testing</h3>
            <p>Key testing strategies include:</p>
            <ul>
                <li>
                    <strong>Unit Testing:</strong> Testing individual Workflow or Activity functions/methods in
                    isolation, mocking their dependencies (like Activity calls within a Workflow, or external services
                    called by an Activity). This focuses on the logic within the component itself.
                </li>
                <li>
                    <strong>Workflow Replay Testing:</strong> Verifying that Workflow code remains deterministic after
                    changes. The SDK uses saved Workflow histories to replay the Workflow logic and ensure it produces
                    the exact same commands. This is vital for safely deploying updates to Workflow definitions.
                </li>
                <li>
                    <strong>Integration Testing (Test Environment):</strong> Testing the interaction between Workflows,
                    Activities, and Workers using a test environment provided by the SDK. This environment simulates
                    the Temporal Cluster, allowing you to run Workflows and Activities locally, testing their
                    interaction and behavior without needing a full Temporal Cluster. This is the most common way to
                    test the end-to-end logic of your Temporal application.
                </li>
                <li>
                    <strong>End-to-End Testing:</strong> Testing the complete application flow, including client
                    invocations, Worker execution, and interactions with real external services (though often mocked
                    or stubbed), potentially against a real Temporal Cluster (like the development server or a staging
                    cluster).
                </li>
            </ul>
        </article>

        <article id="workflow-replay">
            <h3>Workflow Replay Testing</h3>
            <p>
                Workflow replay testing ensures that changes to Workflow code do not break determinism for existing,
                in-flight Workflow Executions. Temporal SDKs typically provide tools or mechanisms to facilitate this.
                The process generally involves:
            </p>
            <ol>
                <li>Obtaining historical event data (Workflow History) for completed Workflow Executions (often saved
                    as JSON files). You can download these using the Temporal CLI or SDK utilities.
                </li>
                <li>Running a test suite that feeds these histories into the updated Workflow code via the SDK's
                    replay functionality.
                </li>
                <li>The replay mechanism executes the Workflow logic against the history. If the updated code produces
                    a different sequence of commands (like trying to schedule a different Activity, using a different
                    timer duration, etc.) than what is recorded in the history, the replay fails, indicating a
                    non-deterministic change.
                </li>
            </ol>
            <p>
                Regularly running replay tests against a corpus of relevant histories is a best practice before
                deploying Workflow code changes.
            </p>
            <!-- TODO: Add code examples for replay testing -->
        </article>

        <article id="testing-environment">
            <h3>Integration Testing with the Test Environment</h3>
            <p>
                Most Temporal SDKs provide a test environment or framework (e.g., `TestWorkflowEnvironment` in Java/Go,
                `WorkflowEnvironment.start_time_skipping` in Python, `TestWorkflowRuntime` in .NET, test utilities in
                TypeScript) that simulates the Temporal Cluster in-process or locally. This allows you to:
            </p>
            <ul>
                <li>Register Workflow and Activity implementations.</li>
                <li>Execute Workflows and Activities directly within your tests.</li>
                <li>Mock Activities called by Workflows.</li>
                <li>Control time within the environment (time skipping) to quickly test timeouts, timers, and long-running
                    processes without waiting in real time.
                </li>
                <li>Assert Workflow completion status, results, or errors.</li>
                <li>Verify Activity invocations and parameters.</li>
            </ul>
            <p>
                This is the primary method for testing the integrated logic of your Workflows and Activities.
            </p>
            <!-- TODO: Add code examples for using the test environment -->
        </article>

    </section>
    <!-- End Testing Section -->

      </main>
    </div> <!-- Close layout-container -->

    <footer>
      <p>Generated documentation combining multiple SDK guides.</p>
    </footer>

    <script src="script.js"></script>
    <!-- Removed incorrect local prism.js script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script> <!-- Added Prism Core JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script> <!-- Added Prism Autoloader for convenience -->
  </body>
</html>
